<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://jiac3366.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiac3366.github.io/"/>
  <updated>2021-11-17T00:02:37.530Z</updated>
  <id>https://jiac3366.github.io/</id>
  
  <author>
    <name>Jiaccc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>架构知识必知必会</title>
    <link href="https://jiac3366.github.io/2021/11/17/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://jiac3366.github.io/2021/11/17/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/</id>
    <published>2021-11-17T00:01:56.868Z</published>
    <updated>2021-11-17T00:02:37.530Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Simple evolution</p><ul><li><p>第一次分离的时候，应用程序、数据库、文件系统分别部署在不同的服务器上</p></li><li><p>使用缓存改善性能，通过缓存读取数据。缓存主要有分布式缓存和本地缓存两种。分布式缓存将多台服务器共同构成一个集群，存储更多的缓存数据</p></li><li><p>因为连接大量的并发用户的访问，通过负载均衡服务器，将应用服务器部署为一个集群</p></li><li><p>数据库的读写分离</p></li><li><p>大多数的互联网应用而言，以上的分布式架构就已经可以满足用户的并发访问压力了</p></li><li><p>更上一层还需要解决：</p><ul><li><p>【海量数据的存储与查询】，主要通过分布式数据库、分布式文件系统、NoSQL 数据库解决</p></li><li><p>【网络带宽压力以及访问延迟】？部署独立的搜索引擎提供查询服务。同时减少数据中心的网络带宽压力，提供更好的用户访问延时、使用 CDN 和反向代理提供前置缓存</p></li><li><p>【实现系统的低耦合与模块化开发和部署】为了使各个子系统更灵活易于扩展，使用分布式消息队列将相关子系统解耦，通过消息的发布订阅完成子系统间的协作、使用微服务架构将逻辑上独立的模块在物理上也独立部署，单独维护，应用系统通过组合多个微服务完成自己的业务逻辑，实现模块更高级别的复用从而更快速地开发系统和维护系统</p></li></ul></li></ul></li><li><p>Cache</p><p>减少 CPU 的计算消耗，节省计算资源<br>​通读缓存（read-through）旁路缓存（cache-aside）区别在于缓存是否负责帮应用程序从数据源读取数据</p><ul><li><p>通读缓存（read-through）</p><p>如果没有，通读缓存就自己负责访问数据源，从数据源获取数据返回给应用程序，并将这个数据缓存在自己的缓存中，通常会作为系统架构的一部分，很多时候对应用程序是透明的</p><ul><li><p>CDN<br>静态内容和动态内容部署在不同的服务器集群上，使用不同的二级域名，即所谓的动静分离</p></li><li><p>反向代理缓存</p><ul><li>设计HTTP代理缓存</li></ul></li></ul></li><li><p>旁路缓存（cache-aside）</p><p>如果没有，就返回空（null）</p><ul><li><p>对象缓存</p><ul><li><p>本地缓存，使用和应用程序在同一个进程的堆空间存放缓存数据</p></li><li><p>分布式缓存</p><p>（每个程序需要依赖一个Memcached 的客户端 SDK）</p><ul><li>应用程序调用 API，API 调用 SDK 的路由算法，路由算法根据缓存的 key 值，计算这个key对应的内容的服务器 IP 地址和端口号，API 再调用 SDK 的通信模块，将 &lt;key, value&gt; 值以及缓存操作命令发送给具体的某台服务器</li></ul></li></ul></li></ul></li><li><p>解决数据脏读问题</p><ul><li><p>过期失效（使用更多）</p></li><li><p>失效通知</p></li><li><p>路由hash算法遇到增加服务器时候，会造成大量缓存不命中，可以用一致性哈希算法解决？？？</p></li></ul></li></ul></li><li><p>Asynchronous architecture（Event driven architecture）</p><ul><li><p>痛点：如何提高系统的写操作的性能呢？两个应用系统之间需要互相调用，其实把两个应用耦合起来了，被调用的应用产生了故障或者升级，都可能会引起调用者故障，或者也不得不升级！</p></li><li><p>消息队列的职责就是缓冲消息，等待消费者消费（在2个相互调用的服务之间增加一个队列）。根据消息消费方式又分为点对点模式和发布订阅模式两种。</p><ul><li><p>点对点模式（保证服务的）</p><ul><li><p>消费者程序可以部署在多台服务器上，但是对于任何一个消息，只会被发送给其中的一个消费者服务器。</p></li><li><p>这些服务器可以根据消息的数量动态伸缩，保证邮件能及时发送。</p></li><li><p>如果有某台消费者服务器宕机，既不会影响其他消费者处理消息发送邮件，也不会影响生产者程序正常运行</p></li></ul></li><li><p>发布订阅模式</p><ul><li><p>在消息队列中设置主题，多个消息消费者可以订阅同一个主题，每个消费者都可以收到这个主题的消息拷贝</p></li><li><p>与点对点区别：消息生产者不需要自行构造不同的业务消息到对应的mq中，只需要把普通数据加入到mq的某个主题，订阅该主题的不同消费者根据自己的业务消费该数据<br>eg 新用户注册的时候一方面需要发送激活邮件，另一方面可能还需要发送欢迎短信，还可能需要将用户信息同步给关联产品或数据库</p></li></ul></li></ul></li><li><p>该架构好处：</p><ul><li><p>改善写操作请求的响应时间</p></li><li><p>更容易进行伸缩</p><ul><li>负载均衡实现集群伸缩，但是这种集群伸缩是以整个应用服务器为单位的，但如果只是某些功能（例如图像处理）有压力，使用mq单独针对图片处理的消费者集群进行伸缩</li></ul></li><li><p>削峰填谷</p><ul><li>消费者可以控制消费速度，降低系统访问高峰时压力，在访问低谷时继续消费消息队列中未处理的消息，保持系统的资源利用率</li></ul></li><li><p>隔离失败</p><ul><li>消费者如果在处理消息的过程中失败，不会传递给生产者</li></ul></li><li><p>降低耦合</p><p>耦合会使软件僵硬、笨拙、难以维护</p><ul><li><p>代码的依赖</p></li><li><p>返回调用结果的依赖<br>如果调用出现异常，应用程序必须要处理这个异常</p></li></ul></li></ul></li></ul></li><li><p>SLB</p><ul><li><p>HTTP 重定向负载均衡（较少用）<br>应用服务器不得不使用公网 IP，外部访问者可以直接连接到应用服务器，系统的安全性会降低</p></li><li><p> DNS 负载均衡</p></li></ul><p>  两次负载均衡，一次通过 DNS 负载均衡，用户请求访问数据中心负载均衡服务器集群的某台机器，然后这台负载均衡服务器再进行一次负载均衡，将用户请求分发到应用服务器集群的某台服务器上.</p><ul><li><p>不同的用户进行域名解析的时候，返回不同的 IP（数据中心负载均衡服务器的 IP ）<br>第一次解析后，域名对应的IP缓存在本机，性能比HTTP重定向好</p></li><li><p>反向代理负载均衡（NGINX）</p><p>应用层负载均衡</p><ul><li><p>反向代理服务器是工作在 HTTP 协议层之上的，代理的也是 HTTP 的请求和响应，效率比较低<br>反向代理负载均衡通常用在小规模的互联网系统上，只有几台或者十几台服务器的规模。</p></li><li><p>IP 负载均衡（有流量瓶颈）</p><p> 网络层负载均衡</p><ul><li><p>在操作系统内核直接修改 IP 数据包的地址，效率高</p></li><li><p>缺点是所有请求都要通过负载均衡服务器进行 IP 地址转换，况且响应的数据很大时会成为响应数据的流量瓶颈</p></li></ul></li></ul></li><li><p> 数据链路层负载均衡 （应用服务器和负载均衡服务器都使用相同的虚拟 IP地址）</p></li></ul><p>  目前大型互联网应用基本都使用链路层负载均衡，虚拟 IP地址是什么原理？</p><ul><li><p>负载均衡服务器并不修改数据包的 IP 地址，响应无需经过负载均衡服务器，解决响应数据量大,输出带宽不足的问题</p></li><li><p>负载均衡服务器的地位和路由器下的交换机类似，修改数据包的MAC地址，响应会直接到达用户的浏览器，而不会再经过负载均衡服务器<br>貌似决定负载均衡服务器交给哪台应用服务器去处理请求，是由用户的 mac 地址决定的<br>​</p></li><li><p>TIPS:</p><ul><li><p>Linux 上实现 IP 负载均衡和链路层负载均衡的技术是 LVS，目前 LVS 的功能已经集成到Linux 中了，通过 Linux 可以直接配置实现这两种负载均衡</p></li><li><p>负载均衡算法有轮询、随机、最少连接</p></li><li><p>写一个简化的 HTTP 重定向负载均衡 demo</p></li></ul></li></ul></li><li><p>Data storage architecture</p><ul><li><p>改善数据存储能力的主要手段包括：数据库主从复制、数据库分片、业务分库和NoSQL 数据库</p></li><li><p>主从复制（提高可用性，无法提升存储能力）</p><ul><li><p>一主多从<br>有的从数据库用来做实时数据分析，有的从数据库用来做批任务报表计算，有的单纯做数据备份</p></li><li><p>两主多从</p><p>两台服务器互相备份，仅仅用来提升数据写操作的可用性，并不能用来提高写操作的性能</p><ul><li>所有的应用程序都必须连接到同一个主数据库进行写操作，只有当该数据库宕机失效的时候，才会将写操作切换到另一台主数据库上。</li></ul></li></ul></li><li><p>业务分库（提高存储能力）</p><ul><li>将不同业务相关的数据库表，部署在不同的服务器上，每一类数据库还可以继续选择使用主从复制，或者主主复制</li></ul></li><li><p>数据库分片（提高存储能力）</p><ul><li><p>硬编码方式分片（根据数据ID映射成服务器编号），缺点是增加节点数，逻辑要修改</p></li><li><p>分布式关系数据库中间件分片（例如MYCAT）–类似查表法</p><ul><li>MYCAT 就可以解析出 SQL 中的地区字段 prov（根据地区进行数据分片），根据这个字段连接相对应的数据库</li></ul></li><li><p>余数 Hash 算法分片（更常见，分布均匀）</p><ul><li>根据主键 ID 和服务器的数目进行取模计算，根据余数连接相对应的服务器</li></ul></li><li><p>一致性hash算法</p></li></ul></li><li><p>NoSQL 数据库（Key、Value 的方式进行数据访问）</p><p>常用的 NoSQL 数据有 Apache HBase，Apache Cassandra、Redis， 与RDMS主要区别可用RDMS的ACID和NoSQL的BASE概括</p><ul><li> CAP 原理</li></ul><p>  一个提供数据服务的分布式系统无法同时满足数据一致性（Consistency）、可用性（Availability）和分区耐受性（Partition Tolerance）这三个条件。</p><ul><li><p>一个分布式系统而言，网络失效一定会发生，也就是说，分区耐受性（P）是必须要保证的，而对于互联网应用来说，可用性也是需要保证的，分布式存储系统通常需要在一致性上做一些妥协和增强</p></li><li><p>Apache Cassandra 解决数据一致性的方案是，在用户写入数据的时候，将一个数据写入集群中的三个服务器节点，等待至少两个节点响应写入成功。用户读取数据的时候，从三个节点尝试读取数据，至少等到两个节点返回数据，并根据返回数据的时间戳，选取最新版本的数据。这样，即使服务器中的数据不一致，但是最终用户还是能得到一个一致的数据，这种方案也被称为最终一致性。</p></li></ul></li></ul></li><li><p>Micro service</p><ul><li><p>单体架构缺点之一：一个巨型的应用必须把应用部署到大规模的服务器集群上。然后每个应用都需要与数据库建立连接，大量的应用服务器连接到数据库，会对数据库的连接产生巨大的压力，某些情况下甚至会耗尽数据库的连接</p></li><li><p>实施微服务最重要的是做好业务的模块化设计，如果业务关系没梳理好，模块设计不清晰，使用微服务架构很可能得不偿失，带来各种挫折</p></li><li><p>中台：-企业级能力复用平台</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Simple evolution&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次分离的时候，应用程序、数据库、文件系统分别部署在不同的服务器上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用缓存改善性能，通过缓存读取数据。缓存主要有分布式缓存和本地缓存两种。分布式缓存将多</summary>
      
    
    
    
    <category term="架构知识" scheme="https://jiac3366.github.io/categories/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>写入etcd的过程</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/etcd%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/etcd%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/</id>
    <published>2021-11-16T23:57:43.379Z</published>
    <updated>2021-11-16T23:58:38.297Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>写入etcd的过程</p><ul><li><p>1、预检查</p><ul><li><p>配额</p></li><li><p>限速</p></li><li><p>鉴权</p></li><li><p>包大小检查</p></li></ul></li><li><p>2、 经过kvSever传到一致性模块（写请求发给了follower会被一致性模块转发给leader）</p><p>基于Raft paper</p><ul><li><p>把请求放入raftLog(Memory暂存)</p></li><li><p>然后同时做2个操作</p><ul><li><p>MsgProp发给其他follower</p></li><li><p>写一个WAL log(二进制的, 将y=9序列化),后台有异步操作落盘 </p></li></ul></li></ul></li><li><p>3、其他follower接收到请求也做写自己raftLog 和WAL，最后给leader返回一个MsgAppResp</p></li><li><p>4、kvSever统计MatchIndex 是否超过半数follower确认,<br>目前还是日志，没有写状态机</p></li><li><p>5、当超半数确认，raftLog中的状态从unstable –&gt;committed，写MVCC模块（状态机）</p><ul><li><p>写treeIndex  key-value形式</p><ul><li><p>key是对象的key, value是版本信息，main revision（eg 最后一次版本号是4）和sub revision（第0次操作）, 所以可以get 某个key对应的revision<img src="https://api2.mubu.com/v3/document_image/450081df-b08d-47c4-a3f2-ed78c711ecb4-12600127.jpg" alt="img"></p></li><li><p>Metadata的resourceVersion读的就是modified信息</p></li><li><p>generation历史变动：3版本创建 历史版本是3和4（有2版本）</p></li></ul></li><li><p>写BoltDB  key-value形式</p><ul><li><p>key是revision</p></li><li><p>value是这条记录的整个信息</p></li></ul></li><li><p>为什么要写WAL呢，直接写MVCC不行吗？</p><ul><li><p>放个地方临时持久化，因为需等待其他follower半数以上同意，又要防止内存断电</p></li><li><p>当等到半数以上同意了，这时如果etcd挂了，大家已经确认的数据就可以直接从WAL中恢复</p></li><li><p>所以WAL是写入状态机之前等待协商的过程保证数据安全用的</p></li></ul></li></ul></li><li><p>6、落盘后，raftLog中的状态从committed–&gt;applied</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;写入etcd的过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、预检查&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配额&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;限速&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;鉴权&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包大小检查&lt;/p&gt;
&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>容器网络基础</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2021-11-16T23:51:18.931Z</published>
    <updated>2021-11-16T23:52:27.724Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>32丨浅谈容器网络</p><ul><li><p>每个容器（把每一个容器看做一台主机）都有“网络栈”，就包括了：网卡（Network Interface）、回环设备（LoopbackDevice）、路由表（Routing Table）和 iptables 规则。</p></li><li><p>如何把这些容器“连接”到 docker0 网桥上？——叫Veth Pair的虚拟设备</p><ul><li><p>特点：被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，被用作连接不同 Network Namespace 的“网线”</p></li><li><p>其2端可以分别在容器和宿主机输入ifconfig查看，宿主机的网卡名字叫作 veth9c02e56，容器网卡名字叫eth0。并且，通过 brctl show 的输出，你可以看到这张网卡被“插”在了 docker0 上</p></li></ul></li><li><p>容器A  ping  容器B是通的，原理：</p><p>把docker0看成交换机，容器的网卡就是docker0交换机的端口，被限制在 NetworkNamespace 里的容器进程，实际上是通过 Veth Pair 设备 + 宿主机网桥的方式，实现了跟同其他容器的数据交换.</p><ul><li><p>首先要查询容器A的路由表查询到容器B的IP的网段要转发的gateway（0.0.0.0），0.0.0.0意味着这是一条直连规则，凡是匹配到这条规则的 IP包，应该经过本机的 eth0 网卡，通过二层网络直接发往目的主机，前提是需要MAC地址</p></li><li><p>容器A通过 eth0 网卡发送ARP广播查找容器B的MAC，docker0负责转发到其他插在它上面的虚拟网卡<br>eth0 网卡，是一个 Veth Pair，它的一端在容器的Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上，从而eth0可以认为是docker0网桥的一个端口</p></li><li><p>容器B因为网卡也插在docker0，回复ARP请求，容器A有了目的 MAC 地址，其 eth0 网卡就可以将数据包发出去</p></li><li><p>docker0处理转发，查询CAM 表（MAC地址表），转发到容器B的端口</p></li><li><p>可以打开iptables的TRACE 验证上述流程<img src="https://api2.mubu.com/v3/document_image/ac5942af-1abd-43bf-916a-d2a864859b64-12600127.jpg" alt="img"><br><a href="https://en.wikipedia.org/wiki/Iptables">iptables - Wikipedia</a></p></li></ul></li><li><p>心得：当你遇到容器连不通“外网”的时候，应该先试试 docker0 网桥能不能ping 通，然后查看一下跟 docker0 和 Veth Pair 设备相关的 iptables 规则（容器里面也有路由表哦，用route命令查看）是不是有异常，往往就能够找到问题的答案了</p></li><li><p>容器的“跨主通信”</p><ul><li>这个粉红色的Overlay Network有点像接在交换机上的路由器？</li></ul></li><li><p>课后：如果要在生产环境中使用容器的 HostNetwork 模式，需要做哪些额外的准备工作呢?</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;32丨浅谈容器网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个容器（把每一个容器看做一台主机）都有“网络栈”，就包括了：网卡（Network Interface）、回环设备（LoopbackDevice）、路由表（Routing Table）和 iptables</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s跨主机通信原理</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-16T23:49:02.369Z</published>
    <updated>2021-11-16T23:50:12.357Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>“跨主通信”的原理</p><ul><li><p>Flannel 支持三种后端实现（本节介绍后2种）</p><p>Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。</p><ul><li><p>host-gw</p></li><li><p>UDP（flanneld 扮演者路由器的角色）</p><p>这个 UDP 包的源地址，就是flanneld 所在的 Node 1 的地址，目的地址是 container-2 所在的宿主机 Node 2 的地址<br>每台宿主机上的 flanneld，都监听着8285 端口</p><ul><li><p>1、出现跨宿主机通信，包会被交给默认路由规则，进入 docker0 与宿主机的路由进行匹配，进入到一个叫作 flannel0的设备，接着交给Flannel进程（内核态向用户态的流动）<br>在 Linux 中，TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备，只负责在操作系统内核和用户应用程序之间传递 IP 包。</p></li><li><p>2、flanneld 收到 IP 包的目的地址，就把它发送给了 Node 2宿主机， 它是如何知道这个 IP 地址对应的容器，是运行在 Node 2 上的？</p><ul><li><p>首先明白： Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网”，子网与宿主机的对应关系，保存在 Etcd<br>docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网</p></li><li><p>flanneld 处理flannel0 传入的 IP 包时，就可以根据目的 IP 的地址（比如100.96.2.3），匹配到对应的子网（比如 100.96.2.0/24），从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.168.0.3</p></li><li><p>若 Node 1 和 Node 2 是互通的，从Node1就可以发送给Node2</p></li></ul></li><li><p>缺点：</p><ul><li>相比于两台宿主机之间的直接通信，多了一个额外的步骤，即 flanneld 的处理过程：由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝<img src="https://api2.mubu.com/v3/document_image/e23ea751-34cb-43a5-8107-68a7729b4928-12600127.jpg" alt="img"></li></ul></li></ul></li><li><p>VXLAN</p><p>Virtual Extensible LAN（虚拟可扩展局域网）， Linux 内核本身就支持的一种网络虚似化技术，VXLAN 可以完全在内核态实现 UDP模式中在用户态进程flanneld:8285的封装和解封装的工作</p><ul><li><p>在现有的三层网络之上，“覆盖”一层虚拟的、由内核VXLAN 模块负责维护的二层网络<br>为在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道”的两端。<br>这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）作用和跟前面的 flanneld 进程十分类似<br>​差别在于封装和解封装的对象是二层数据帧；执行流程是在内核里完成的（因为 VXLAN 本身就是 Linux 内核中的一个模块）</p></li><li><p>Node 2 启动并加入 Flannel 网络之后， Node 1（以及所有其他节点）的flanneld 就会添加一条到 Node2 VTEP设备IP的路由规则<br>flannel.1 设备( VTEP 设备)替代了原flannel0 设备和主机eth0</p></li><li><p>VTEP 设备收到docker0发来的“原始 IP包”要想办法加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 VTEP 设备”，那么目的 VTEP 设备”的 MAC 地址是什么？因为Node1已有到Node2 VTEP的IP，所以自然要使用ARP，需要的 ARP 记录，也是 flanneld 进程在 Node 2 节点启动时自动添加在 Node 1上<br>（不依赖 L3 MISS 事件和 ARP 学习）可以通过 ip 命令查看——ip neigh show dev flannel.1<br>（ VTEP 设备和宿主机都有MAC地址哦）</p></li><li><p>加上“目的 VTEP 设备”的 MAC 地址，得到一个“内部数据帧”，但并不能在宿主机二层网络里传输<img src="https://api2.mubu.com/v3/document_image/0aa63b4a-3d17-492c-8a0a-3bb0ebb8be59-12600127.jpg" alt="img"></p></li><li><p>Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧，让它载着完整的二层数据帧，通过宿主机的 eth0 网卡进行传输，把这次要封装出来的、宿主机对应的数据帧称为“外部数据帧”（Linux 内核会把这个数据帧封装进一个 UDP 包里发出去）<br>Linux 内核会在“内部数据帧”前面，加上一个VXLAN 头表示“乘客”实际上是一个 VXLAN 要使用的数据帧，VXLAN 头里有个标志叫VNI，是 VTEP 设备识别某个数据帧是否归自己处理的重要标识。在 Flannel 中宿主机上的VTEP 设备都叫作 flannel.1 ，原因是这个“1”是VNI 标志的默认值</p></li><li><p>flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对方的宿主机地址的IP地址， UDP 包该发给哪台宿主机呢？</p><ul><li>flannel.1 设备实际扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自一个叫FDB（Forwarding Database）的转发数据库（相当于交换机的MAC表），bridge fdb 命令可以查看对方宿主机的IP<br> FDB 信息，也是 flanneld 进程负责维护的<br>bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37(对方 VTEP 设备的MAC，由ip neigh show dev flannel.1查出来的)</li></ul></li><li><p>Linux封包发送（Node 2 的 MAC 地址，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护）<img src="https://api2.mubu.com/v3/document_image/b73d8f15-bcc0-43b3-b356-4e43941ef15a-12600127.jpg" alt="img"></p></li><li><p>对方接受<img src="https://api2.mubu.com/v3/document_image/a77ec334-ab64-4c45-bdab-bd22825107e1-12600127.jpg" alt="img"></p></li></ul></li><li><p>后两种模式其实都可以称作“隧道”机制，也是很多其他容器网络插件的基础。比如 Weave 的两种模式，以及 Docker 的 Overlay 模式。</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“跨主通信”的原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Flannel 支持三种后端实现（本节介绍后2种）&lt;/p&gt;
&lt;p&gt;Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ho</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s权限控制模型 RBAC</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%20RBAC/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%20RBAC/</id>
    <published>2021-11-16T23:46:32.111Z</published>
    <updated>2021-11-16T23:49:53.623Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>很多实际的容器化工作，都会要求你设计一个自己的编排对象，实现自己的控制器模式。</p></li><li><p> K8s 里新增和操作 API 对象，必须先了解RBAC</p></li></ul><p>  负责完成授权（Authorization）工作的机制，就是 RBAC<br>  ​</p><ul><li><p>3大概念（Role + RoleBinding + ServiceAccount）</p><ul><li><p>Role</p><ul><li><p>产生作用的 Namepace 是：mynamespace<br>Namespace 并不会提供任何实际的隔离或者多租户能力</p></li><li><p>rules 字段，就是它所定义的权限规则<br>在上面的例子里：允许“被作用者”，对 mynamespace 下面的 Pod 对象，进行 GET、WATCH 和 LIST 操作<br>​</p></li></ul></li><li><p>RoleBinding</p><p>可以指定上面Role的“被作用者”</p><ul><li><p>“User”字段，只是一个授权系统里的逻辑概念</p><p>大多数私有的使用环境中，我们只要使用 Kubernetes 提供的内置“用户”，就足够</p><ul><li><p>可以通过外部认证服务，比如 Keystone来提供keystone?</p></li><li><p>也可以直接给 APIServer 指定一个用户名、密码文件</p></li></ul></li><li><p>roleRef字段</p><ul><li><p>绑定我们前面定义的 Role 对象（example-role）</p></li><li><p>Role对权限的限制规则仅在自己的 Namespace 内有效，roleRef 也只能引用当前 Namespace 里的 Role 对象</p></li></ul></li></ul></li><li><p>Subject(User)——一般用ServiceAccount，是由 k8s负责管理的“内置用户”</p><ul><li><p>ServiceAccount<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  namespace: mynamespace<br>  name: example-sa</p></li><li><p>RoleBinding  下面的example-role在上面已经创建<img src="https://api2.mubu.com/v3/document_image/d040165b-09c4-44c8-9bc8-2aba91c9c133-12600127.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/0fe1e25b-2dcf-4eb1-b70f-105dbb24c901-12600127.jpg" alt="img"></p></li><li><p>实践：用Pod绑定按上述步骤创建的ServiceAccount</p><ul><li><p>Pod引用这个serviceAccount的name，创建成功后的Secret 对象（但cncamp课程演示 sa一旦被创建secrete就也一起被创建）（ServiceAccount 对应的用来跟 APIServer 进行交互的授权文件：Token）被mount到pod里面的/var/run/secret/<a href="http://k8s.io/sa()%E7%BC%A9%E5%86%99">k8s.io/sa(</a> ，pod应用带着它访问apiserver，apiserver就知道你是谁<img src="https://api2.mubu.com/v3/document_image/7e2fb66a-c287-426f-86ce-240760893cfc-12600127.jpg" alt="img"><br>Token 文件的内容一般是证书或者密码，以 Secret对象的方式保存在 Etcd </p></li><li><p>kubectl describe pod sa-token-test -n mynamespace   可以查看该 ServiceAccount 的 token<br>eg ：被 k8s自动挂载到了容器的/var/run/secrets/<a href="http://kubernetes.io/serviceaccount">kubernetes.io/serviceaccount</a>，容器里的应用就可以使用里面的 ca.crt 来访问 APIServer 了</p></li><li><p>tips:</p><ul><li><p>Pod 没有声明 serviceAccountName，Kubernetes 会自动在它的 Namespace 下创建一个名叫 default 的默认 ServiceAccount，然后分配给这个 Pod，有访问 APIServer 的绝大多数权限</p></li><li><p>你可以通过describe sa default查看对应的secret对象，也可以通过kubectl describe secret default-token-s8rbq查看对应的sa对象</p></li></ul></li></ul></li><li><p>用户组：一个 ServiceAccount，在 Kubernetes 里对应的“用户”的名字<br>system:serviceaccount:&lt;ServiceAccount 名字 &gt;</p></li><li><p>而它对应的内置“用户组”的名字<img src="https://api2.mubu.com/v3/document_image/128362d8-4094-47cb-b475-14b825527569-12600127.jpg" alt="img"><br>system:serviceaccounts:&lt;Namespace 名字 &gt;<br>name: system:serviceaccounts就意味着这个 Role 的权限规则，作用于整个系统里的所有 ServiceAccount</p></li></ul></li><li><p>更大的授权</p><p>：对于非 Namespaced（Non-namespaced）对象（比如：Node），或者某一个 Role 想要作用于所有的 Namespace 的时候，我们又该如何去做授权呢？</p><ul><li><p>ClusterRole和ClusterRoleBinding</p><p>用法跟 Role 和 RoleBinding 完全一样，只是没有了ns字段</p><ul><li><p>k8s内置了很多为系统保留的 ClusterRole</p><ul><li><p>eg ：system:kube-scheduler<br>绑定给 kube-system Namesapce下名叫 kube-scheduler 的 ServiceAccount（k8s调度器的 Pod 声明使用的 ServiceAccount）</p></li><li><p>1.cluster-admin；2. admin；3. edit；4. view<br>务必要谨慎而小心地使用 cluster-admin（cluster-admin是最高权限（verbs=*））</p></li></ul></li></ul></li><li><p>Role 或者 ClusterRole 里，如果要赋予用户 (是User，不是ServiceAccount )example-user 所有权限，那就可以给它指定一个 verbs 字段的全集<br> verbs: [“get”, “list”, “watch”, “create”, “update”, “patch”, “delete”]</p></li></ul></li><li><p>更细化的授权</p><ul><li>这条规则的“被作用者”，只对名叫“my-config”的 ConfigMap 对象，有进行 GET 操作的权限<img src="https://api2.mubu.com/v3/document_image/c24c7790-e127-4d0d-b7e1-6d81813ed574-12600127.jpg" alt="img"></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很多实际的容器化工作，都会要求你设计一个自己的编排对象，实现自己的控制器模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; K8s 里新增和操作 API 对象，必须先了解RBAC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  负责完成授权（Authorization）</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>API对象的奥秘！</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/API%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98%EF%BC%81/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/API%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98%EF%BC%81/</id>
    <published>2021-11-16T23:45:06.990Z</published>
    <updated>2021-11-16T23:50:32.264Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p> K8s是如何对 Resource、Group 和 Version 进行解析，从而找到 对象的定义呢</p></li><li><p>1、会匹配 API 对象的组<br>核心 API 对象，比如：Pod、Node 等， Group 是“”（不需要Group）会直接在 /api 这个层级进行下一步的匹配过程</p></li><li><p>2、匹配到 API 对象的版本号<br>同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。<br>比如在 CronJob 的开发过程中，对于会影响到用户的变更就可以通过升级新版本来处理，从而保证了向后兼容</p></li><li><p>3、Kubernetes 会匹配 API 对象的资源类型</p></li><li><p>APIserver交互流程</p><ul><li><p>1、授权、超时处理、审计</p></li><li><p>2、MUX 和 Routes 流程<br>APIServer 完成 URL 和 Handler 绑定的场所</p></li><li><p>3、APIServer 进行Convert 工作，把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。<br>这样用户提交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理</p></li><li><p>4、 Admission() 和 Validation() 操作</p><ul><li><p>上节提到的的 Admission Controller 和 Initialize</p></li><li><p>Validation，则验证这个对象里的各个字段是否合法<br>只要一个 API 对象的定义能在 Registry 里查到，它就是一个有效的 Kubernetes API 对象</p></li></ul></li><li><p>5、APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 保存</p></li></ul></li><li><p>自定义CRD</p><ul><li><p>通俗说：为了让k8s认识这个对象</p><ul><li> register.go</li></ul><p>  pkg/apis/samplecrd/register.go</p><ul><li><p>放置后面要用到的全局变量</p></li><li><p>doc.go 起到的是全局的代码生成控制的作用  被称为 Global Tags<br>pkg/apis/samplecrd/doc.go,<br>+k8s:deepcopy-gen=package 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；<br>而+groupName=<a href="http://samplecrd.k8s.io/">samplecrd.k8s.io</a>，则定义了这个包对应的 API组的名字。</p></li><li><p> types.go </p></li></ul><p>  pkg/apis/samplecrd/types.go<br>  ​由于 Global Tags，不需要再显式地加上 +k8s:deepcopy-gen=true 了</p><ul><li><p>TypeMeta</p></li><li><p>ObjectMeta</p></li><li><p>Spec</p><ul><li><p>Cidr</p></li><li><p>Gateway</p></li></ul></li><li><p>register.go——addKnownTypes()</p><p>pkg/apis/samplecrd/v1/register.go</p><ul><li>让客户端也能“知道CRD, APIServer 会自动帮我们完成在服务器端的注册</li></ul></li><li><p>代码生成工具为资源类型生成clientset、informer 和 lister（详看PDF）<img src="https://api2.mubu.com/v3/document_image/439c380b-e645-4096-a36c-ce631e88e4f9-12600127.jpg" alt="img"></p></li><li><p>把其中的资源类型、GroupName 和 Version 替换成你自己的定义</p></li></ul></li><li><p>总结自定义对象工作分2部分：</p><ul><li><p>自定义资源类型的 API 描述<br>组Group、版本（Version）、资源类型（Resource）</p></li><li><p>自定义资源类型的对象描述<br>Spec、Status</p></li></ul></li></ul></li><li><p>tip:用 kubebuild 自动生成项目框架，添加自己的 CRD 并实现 controller 即可<img src="https://api2.mubu.com/v3/document_image/41bc3d9e-92b6-46f5-a9cb-a7996482f4eb-12600127.jpg" alt="img"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt; K8s是如何对 Resource、Group 和 Version 进行解析，从而找到 对象的定义呢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1、会匹配 API 对象的组&lt;br&gt;核心 API 对象，比如：Pod、Node 等， Group 是“”（不需要Grou</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>声明式API与Kubernetes编程范式</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%E4%B8%8EKubernetes%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%E4%B8%8EKubernetes%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</id>
    <published>2021-11-16T23:41:27.313Z</published>
    <updated>2021-11-16T23:44:37.046Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>先 kubectl create，再 replace 的操作，称为命令式配置文件操作。</p></li><li><p>什么才是“声明式 API”——kubectl apply </p><p>创建和修改都用kubectl apply</p><ul><li><p>kubectl replace 是使用新的 YAML 文件中的API 对象，替换原有的 API 对象，一次只能处理一个写请求</p></li><li><p>kubectl apply是执行一个对原有 API 对象的PATCH 操作，一次能处理多个写操作，并且具备 Merge 能力</p></li></ul></li><li><p>Envoy——讲解一下声明式 API 在实际使用的重要意义</p><p>Envoy是一个高性能 C++ 网络代理，istio 的控制层（Control Plane）里的 Pilot 组件，能通过调用每个 Envoy容器的 API对Envoy 代理进行配置，实现微服务治理</p><ul><li><p>Envoy以 sidecar 容器的方式运行在每被治理的应用Pod 中，通过配置 Pod 里的 iptables 规则，接管整个 Pod 的进出流量</p></li><li><p>DynamicAdmission Control  ——“热插拔”式的 Admission 机制，也叫作：Initializer。</p><ul><li><p>背景： K8s 的1个 Pod 或者1个 API 对象被提交给 APIServer ，有一些“初始化”性质的工作需要在它们被正式处理之前进行<br>eg: 自动为所有 Pod 加上某些标签（Labels）</p></li><li><p>Istio 项目要做的，就是在1个 Pod YAML 被提交给 K8s 之后，在里面自动加上 Envoy 容器的配置</p><ul><li><p>Istio 会将 Envoy 容器本身的定义，以 ConfigMap 的方式保存，这个 ConfigMap 的 data 部分，正是一个 Pod 对象的一部分定义，所以会有重叠，所以更新用户的 Pod 对象的时候，必须使用 PATCH API 来完成<img src="https://api2.mubu.com/v3/document_image/2ed31cbd-2a90-4e4e-9ec5-b71a73b5259f-12600127.jpg" alt="img"></p></li><li><p>Istio 将一个编写好的 Initializer，作为一个 Pod 部署在 K8s 中，其中这个Initializer的工作过程如下：</p><p>这个 envoy-initializer 使用的 envoy-initializer:0.0.1 镜像，是一个事先写好的“自定义控制器”（Custom Controller），在下一篇文章中讲解</p><ul><li><p>initializer 控制器</p><ul><li><p>1、不断检查有无新pod创建,  实际就是死循环，逻辑伪代码<img src="https://api2.mubu.com/v3/document_image/aa117a1a-8f80-4afd-a19d-d06ea4fb79bc-12600127.jpg" alt="img"></p></li><li><p>2、从 APIServer 中拿ConfigMap的data</p></li><li><p>3、将 ConfigMap 里存储的 containers 和 volumes 字段，直接添加进一个空的Pod 对象里</p></li><li><p>4、使用k8sAPI，使用新旧两个 Pod 对象，生成一个 TwoWayMergePatch<img src="https://api2.mubu.com/v3/document_image/677b5a47-191c-44fb-a771-8ba04bd65547-12600127.jpg" alt="img"></p></li><li><p>5、调用 K8s 的 Client，发起一个 PATCH 请求</p></li><li><p>ps、指定要对什么样的资源起作用</p><ul><li>成功创建后，新创建的 Pod 的 Metadata 上就有这个Initializer的name，但initializer 里完成了要做的操作后，一定要记得将metadata.initializers.pending 标志清除掉<img src="https://api2.mubu.com/v3/document_image/2086faad-03cc-43a1-8017-f644bf38ecf8-12600127.jpg" alt="img"></li></ul></li><li><p>ps、在具体的 Pod 的 Annotation 里声明要使用哪个 Initializer,   eg：Annotation写<a href="http://initializer.kubernetes.io/envoy=true,">initializer.kubernetes.io/envoy=true,</a> 就会使用到我们前面所定义的envoy-initializer<img src="https://api2.mubu.com/v3/document_image/f1b02564-efe0-451d-bbaa-40b3de99b193-12600127.jpg" alt="img"></p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>如何理解“Kubernetes 编程范式”，如何为 Kubernetes 添加自定义 API 对象，编写自定义控制器，正是这个晋级过程中的关键点</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先 kubectl create，再 replace 的操作，称为命令式配置文件操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么才是“声明式 API”——kubectl apply &lt;/p&gt;
&lt;p&gt;创建和修改都用kubectl apply&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>StatefulSet是什么？</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/StatefulSet%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/StatefulSet%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2021-11-16T23:40:12.242Z</published>
    <updated>2021-11-16T23:40:43.263Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>18 深入理解StatefulSet（一）：拓扑状态</p><p>实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用” Stateful Application</p><ul><li><p>StatefulSet把真实世界的应用抽象成2种情况</p><p>在部署“有状态应用”的时候，应用的每个实例拥有唯一并且稳定的“网络标识”，是一个非常重要的假设</p><ul><li><p>拓扑状态</p></li><li><p>存储状态（下一节讲）</p></li></ul></li><li><p>Service被访问的方式有2种</p><ul><li><p>一、Service的虚拟 IP</p></li><li><p>二、Service的DNS</p><ul><li><p>访问这个dns，正是这个 Service 的 VIP，和（一）一致</p></li><li><p>访问这个dns直接解析出被代理 Pod 的 IP 地址，这就叫 Headless Service</p></li></ul></li></ul></li><li><p>小实践</p><ul><li><p>先创建 Headless Service</p><p>Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址<br>​仍是一个标准 Service 的 YAML 文件。只不过它的 clusterIP 字段的值是：None</p><ul><li>创建后，它所代理的所有 Pod（label selector选出来的） 的 IP 地址，都会被绑定一个DNS 记录</li></ul></li><li><p>再创建statefulset</p><p>只要知道了一个 Pod 的名字，以及它对应的 Service 的名字，就可通过这条 DNS 记录访问到 Pod 的 IP  </p><ul><li>和deployment YAML的唯一区别，就是多了一个 serviceName=nginx 字段，StatefulSet控制器会使用这个叫nginx 的Headless Service 来保证 Pod 的可解析身份（DNS记录）</li></ul></li><li><p>这时候创建一个pod  对statefulset维护的2个pod nslookup  和删除这2个pod后再nslookup  结果一致，说明Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来。<br>注意：解析到的Pod 的 IP 地址，并不是固定的，所以对于“有状态应用”实例的访问，你必须使用 DNS 记录或者 hostname 的方式</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;18 深入理解StatefulSet（一）：拓扑状态&lt;/p&gt;
&lt;p&gt;实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用” Stateful Application&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;StatefulSet把真实世界</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>Depolymnet、ReplicaSet、Pod之间的关系</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/Depolymnet%E3%80%81ReplicaSet%E3%80%81Pod%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/Depolymnet%E3%80%81ReplicaSet%E3%80%81Pod%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2021-11-16T23:38:28.668Z</published>
    <updated>2021-11-16T23:50:23.412Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>只有容器能保证自己始终是 Running 状态的前提下，ReplicaSet 调整 Pod 的个数才有意义<br>也正是 Deployment 只允许容器的 restartPolicy=Always的原因</p></li><li><p>deployment状态字段</p><ul><li><p> kubectl scale deployment nginx-deployment –replicas=4  水平扩展</p></li><li><p>kubectl rollout status deployment/nginx-deployment<br>查看 nginx-deployment 的状态变化</p></li></ul></li><li><p>ReplicaSet 的 DESIRED、CURRENT 和 READY 字段的含义，和 Deployment 一致。<br>相比之下，Deployment 只是在 ReplicaSet 的基础上，添加了 UP-TO-DATE 这个跟版本有关的状态字段</p></li><li><p>使用 Pod 的 Health Check 机制检查应用的运行状态，当“滚动更新”停止，旧版本还能继续服务<br>容器 Running 状态时，但服务很有可能尚未启动，“滚动更新”的效果也就达不到了</p></li><li><p>Deployment、ReplicaSet 和 Pod 的关系.</p><ul><li><p>Deployment 的控制器控制的是 ReplicaSet 的数目（描述应用的版本），以及每个ReplicaSet 的属性（来保证 Pod 的副本数量）<br>：Deployment 控制 ReplicaSet（版本），ReplicaSet 控制 Pod（副本数）——deploy的yaml文件中同时定义replicaset和container，replicaset的replicas字段就是控制副本数的</p></li><li><p>1个应用的版本，对应的是1个 ReplicaSet，这个版本应用的 Pod 数量，则由ReplicaSet 通过它自己的控制器（ReplicaSet Controller）来保证</p><ul><li><p>对 Deployment 进行的每一次更新操作，都会生成一个新的 ReplicaSet 对象,会比较浪费资源</p><ul><li><p>1、kubectl rollout<br>在更新 Deployment 前，先执行 kubectl rollout pause deployment/nginx-deployment 让Deployment 处于“暂停”状态，这时对 Deployment 的所有修改，都不会触发新的“滚动更新”，也不会创建新的 ReplicaSet最后执行 kubectl rollout resume deploy/nginx-deployment 恢复回来</p></li><li><p>2、Deployment 对象字段， spec.revisionHistoryLimit<br>k8s为 Deployment 保留的“历史版本”个数，设置为 0，就再也不能做回滚操作了</p></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只有容器能保证自己始终是 Running 状态的前提下，ReplicaSet 调整 Pod 的个数才有意义&lt;br&gt;也正是 Deployment 只允许容器的 restartPolicy=Always的原因&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;deployme</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>控制器模型是怎样的？</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/</id>
    <published>2021-11-16T23:36:56.605Z</published>
    <updated>2021-11-16T23:38:06.312Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>CRD 就是一个专门用来定义 Schema 的一个特殊的 API 对象</p></li><li><p>控制循环——“ReconcileLoop”（调谐循环）或者“Sync Loop”（同步循环）</p></li><li><p>被控制对象的定义，则来自于一个“模板”。</p><p>控制循环最后的执行结果，要么创建、更新一些Pod（或者其他的 API 对象、资源），要么删除一些已经存在的 Pod（或者其他的API 对象、资源）。</p><ul><li><p>Deployment 这样的一个控制器，上半部分是控制器定义（包括期望状态），下半部分的是被控制对象的模板</p></li><li><p>eg:  Deployment 里的 template 字段（PodTemplate（Pod 模板）），被这个 Deployment 管理的 Pod 实例，都是根据这个template 字段的内容创建的</p></li><li><p>问题：</p><ul><li><p>Kubernetes 使用的这个“控制器模式”，跟我们平常所说的“事件驱动”，有什么区别和联系吗？</p><ul><li><p>相当于select和epoll的区别</p></li><li><p>事件往往是一次性的，如果操作失败比较难处理，但是控制器是循环一直在尝试的，更符合kubernetes声明式API，最终达到与声明一致</p></li></ul></li><li><p>控制器主动获取pod状态，在这个集群中，有那么多pod，某个pod在某一时刻状态有变，怎样及时通知到控制器呢？informer机制</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CRD 就是一个专门用来定义 Schema 的一个特殊的 API 对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;控制循环——“ReconcileLoop”（调谐循环）或者“Sync Loop”（同步循环）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;被控制对象的定义，则来</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Pod对象</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E5%AF%B9%E8%B1%A1/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-11-16T23:33:26.186Z</published>
    <updated>2021-11-16T23:51:01.944Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>13 为什么需要Pod？</p><ul><li><p>背景：容器的“单进程模型”<br>容器没有管理多个进程的能力，因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程，用户进程没有管理其他进程的能力</p></li><li><p>解决：k8s把协同工作在同1个“进程组”的多个线程等价为1个Pod的多个容器，解决典型的成组调度（gang scheduling）问题，在Pod的层面进行资源分配（多个容器加起来需要的总资源作为一个原子调度单位）<br>具有“超亲密关系”容器的典型特征包括但不限于：互相之间会发生直接的文件交换、使用 <a href="http://localhost/">localhost</a> 或者 Socket 文件进行本地通信、会发生非常频繁的远程调用、需要共享某些 Linux Namespace（比如，一个容器要加入另一个容器的 Network Namespace）</p></li><li><p>重要：Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume|</p></li><li><p>A加入B的前提是B首先启动，所以为了保持Pod 里的多个容器就是对等关系：</p><ul><li>Pod 的实现需要使用一个中间容器，这个容器叫作 Infra 容器。在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，用户定义的容器通过 Join Network Namespace 的方式，与 Infra 容器关联在一起，要为 Kubernetes 开发一个网络插件时只需要关注如何配置 Infra 容器的 Network Namespace 即可.</li></ul></li><li><p>用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器</p><ul><li><p>例子1：war包和tomcat分别做成2个镜像，war包是个 Init Container 类型的容器，它会按顺序逐一启动，等到他们启动并退后，spec.containers 定义的用户容器才启动，后面的tomcat（与war容器挂载了同一Volume）就看到Volume对应的宿主机目录中有war包</p><ul><li>上述例子是容器设计模式里最常用的一种模式：sidecar<br>sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。很多与 Pod 网络相关的配置和管理，也都可以交给 sidecar 完成，而完全无须干涉用户容器。最典型的例子莫过于 Istio 这个微服务治理项目</li></ul></li><li><p>例子2：一个最基本的日志收集工作：A往Volume中写日志，B也声明挂载同一个 Volume，然后B可以读取日志文件，转发到 MongoDB 或者 Elasticsearch 中存储起来。</p></li></ul></li><li><p>虚拟机和容器区别：</p><ul><li><p>部署方式：容器无法像虚拟机那样完全模拟本地物理机环境</p><ul><li><p>一个运行在虚拟机里的应用是被管理在 systemd 或者supervisord 之下的一组进程，而不是一个进程。<br>Swarm 这种单容器的工作方式，就难以描述真实世界这种复杂的应用架构，需要把一个运行在虚拟机里的应用迁移到 Docker 容器中时，要仔细分析到底有哪些进程（组件）运行在这个虚拟机</p></li><li><p>Pod实际上是在扮演“虚拟机”的角色；而容器只是一个进程，扮演这个虚拟机里运行的用户程序。</p></li></ul></li></ul></li></ul></li><li><p>14 深入理解Pod对象（一）（Pod对象字段）</p><ul><li><p>API对象到底哪些属性属于 Pod 对象，而又有哪些属性属于Container 呢？</p><p>——把 Pod 看成传统环境里的“机器”、把容器看作是运行在这个“机器”里的“用户程序”</p><ul><li><p>常用的Pod字段：(在第一个spec下)</p><p>凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的</p><ul><li><p>NodeSelector: a:b 这个 Pod 永远只能运行在携带了“a: b”标签（Label）的节点</p></li><li><p>HostAliases: 定义了 Pod 的 hosts 文件（比如 /etc/hosts），设置 hosts 文件一定要通过这种方法</p></li><li><p>shareProcessNamespace: true </p><ul><li>Pod 里的容器共享 PID Namespace<br>整个 Pod 里的每个容器的进程，对于所有容器来说都是可见的<br>​k attach -it nginx -c shell？？为啥无法交互了</li></ul></li><li><p>Pod共享宿主机的 Network、IPC 和 PID Namespace</p><ul><li><p>hostNetwork: true</p></li><li><p>hostIPC: true </p></li><li><p>hostPID: true</p></li></ul></li><li><p>container字段  –在deployment对象的第二个spec下，以下字段是container字段的属性</p><ul><li><p>Image（镜像）</p></li><li><p>Command（启动命令）</p></li><li><p>workingDir（容器的工作目录）</p></li><li><p>Ports（容器要开的端口）</p></li><li><p>volumeMounts（容器要挂载的 Volume）</p></li><li><p>imagePullPolicy </p><ul><li><p>默认值是 Always，即每次创建 Pod 都重新拉取一次镜像</p></li><li><p>Never ：Pod 永远不会主动拉取这个镜像</p></li><li><p>IfNotPresent：只有宿主机上不存在这个镜像时才拉取</p></li></ul></li><li><p>Lifecycle</p><ul><li><p>postStart指在容器启动后，立刻执行一个指定的操作<br>并不严格保证顺序，在 postStart 启动时，ENTRYPOINT 有可能还没有结束</p></li><li><p>preStop发生的时机是容器被杀死之前（比如，收到了 SIGKILL 信号）<br>会阻塞当前的容器杀死流程，直到这个 Hook 定义操作完成之后，才允许容器被杀死，和postStart不一样</p></li></ul></li></ul></li><li><p>Status</p><ul><li><p>pod.status.phase，是 Pod 的当前状态</p><ul><li><p>Pending 已提交给etcd,因为某种原因而不能被顺利创建, 比如调度不成功。</p></li><li><p>Running Pod 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中</p></li><li><p>Succeeded Pod 里的所有容器都正常运行完毕，并且已经退出了（1次性任务）</p></li><li><p>Failed Pod 里至少有一个容器以不正常的状态（非 0 的返回码）退出。需要查看 Pod 的 Events和日志</p></li><li><p>Unknown Pod 的状态不能持续地被 kubelet 汇报给kube-apiserver——主从节点（Master 和 Kubelet）间的通信出现了问题</p><ul><li><p>Conditions</p><p>type：PodScheduled、Ready、Initialized，以及 Unschedulable,主要用于描述造成当前 Status 的具体原因是什么。</p><ul><li><p>Pending: 对应的 Condition 是 Unschedulable， 调度出现了问题。</p></li><li><p>Ready： Pod 不仅已经正常启动（Running 状态），而且已经可以对外提供服务了</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>15 深入理解Pod对象（二）</p><ul><li> Projected Volume ——具备自动更新的能力</li></ul><p>  这些特殊 Volume 的作用，是为容器提供预先定义好的数据。所以，从容器的角度来看，这些 Volume 里的信息就是仿佛是被Kubernetes“投射”（Project）进入容器中的</p><ul><li><p>Secret</p><p>数据库的验证信息</p><ul><li><p>创建方式</p><ul><li><p>在Pod yaml：先在volumes字段声明挂载的 是projected 类型，并为 Secret 对象指定的名字，再kubectl create secret generic user –from-file=./username.txt，其中user 是为 Secret 对象指定的名字</p></li><li><p>单独YAML</p></li></ul></li><li><p>通过挂载方式进入到容器里的 Secret， kubelet 组件在定时维护这些 Volume<br>一旦其对应的 Etcd 里的数据被更新，这些 Volume 里的文件内容，同样也会被更新，但会有一定的延时。所以在编写应用程序时，在发起数据库连接的代码处写好重试和超时的逻辑，绝对是个好习惯</p></li></ul></li><li><p>ConfigMap</p><p>环境变量</p><ul><li>与Secret基本一致，区别是不需要加密其中的信息</li></ul></li><li><p>Downward API</p><ul><li><p>声明要暴露 Pod 的某些信息（Pod 里的容器进程启动之前就能确定的信息）给容器，具体的可以查阅一下官方文档.例如</p><ul><li><p>使用 fieldRef 声明：</p><ul><li><p>spec.nodeName - 宿主机名字   </p></li><li><p>status.hostIP - 宿主机 IP</p></li><li><p><a href="http://metadata.name/">metadata.name</a> - Pod 的名字</p></li><li><p>metadata.namespace - Pod 的 Namespace等</p></li></ul></li><li><p>使用 resourceFieldRef 声明：</p><ul><li><p>容器的 CPU limit</p></li><li><p>容器的 CPU request</p></li><li><p>容器的 memory limit</p></li><li><p>容器的 memory request</p></li></ul></li></ul></li></ul></li><li><p>ServiceAccountToken（特殊的Secret对象）？？？有点模棱两可</p><p>Service Account（k8s进行权限分配的对象） 的授权信息（Token）和文件，实际保存在ServiceAccountToken</p><ul><li>从容器里直接访问Kubernetes 的 API 需要ServiceAccountToken的Token<br>Kubernetes 其实在每个 Pod 创建的时候，自动在它的spec.volumes 部分添加上了默认 ServiceAccountToken 的定义，然后自动给每个容器加上了对应的 volumeMounts 字段。简单说，默认就加载了授权信息可以访问k8sAPI</li></ul></li><li><p>容器健康检查和恢复机制</p><p>为 Pod 里的容器定义一个健康检查“探针”（Probe），kubelet 根据 Probe 的返回值决定容器的状态</p><ul><li><p>健康检查</p><ul><li><p>livenessProbe字段，kubelet 根据 健康检查“探针”Probe 的返回值决定容器的状态</p></li><li><p>readinessProbe，决定的这个 Pod 是不是能被通过 Service 的方式访问到，而并不影响 Pod 的生命周期</p></li></ul></li><li><p>Pod 恢复机制 </p><p>Pod 的恢复过程是重新创建容器，永远都是发生在当前节点上，除非使用Deployment控制器</p><ul><li><p>restartPolicy</p><ul><li><p>pod.spec.restartPolicy默认是Always。<br>但如果只计算 1+1=2，计算完成输出结果后退出，变成 Succeeded 状态；所以设为Always没有意义</p></li><li><p>OnFailure: 只在容器 异常时才自动重启容器</p></li><li><p>Never: 从来不重启容器<br>需要关心容器退出后的日志、文件和目录时这样设置</p></li></ul></li><li><p>列表信息的STATUE字段</p><ul><li><p>Failed的场景</p><ul><li><p>运行1个容器的pod在restartPolicy=Never时出现</p></li><li><p>运行多个容器的pod中所有容器异常</p></li></ul></li></ul></li></ul></li></ul></li><li><p>（运维人员预先定义）PodPreset  + （开发人员编写,标记上相关的selector）pod  = 完整的pod yaml<br>PodPreset  里定义的内容会在 Pod API 对象被创建之前追加在这个对象本身上，不会影响任何 Pod 的控制器的定义，比如这个Pod的 Deployment 对象本身是永远不会被 PodPreset改变，k8s还会Merge多个 PodPreset 要做的修改，如果它们要做的修改有冲突，这些冲突字段就不会被修改</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;13 为什么需要Pod？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景：容器的“单进程模型”&lt;br&gt;容器没有管理多个进程的能力，因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程，用户进程没有管理其他进程的能力&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/26/golang/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/"/>
    <id>https://jiac3366.github.io/2021/10/26/golang/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</id>
    <published>2021-10-26T13:20:32.639Z</published>
    <updated>2021-10-26T13:44:32.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1108-IP-地址无效化"><a href="#1108-IP-地址无效化" class="headerlink" title="1108. IP 地址无效化"></a>1108. IP 地址无效化</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>golang <code>string</code>和<code>[]byte</code>的区别？</li><li>如何转换？</li></ul><p>根据[golang string和<a href="https://www.cnblogs.com/zhangboyu/p/7623712.html">]byte的对比 - 张伯雨 - 博客园 (cnblogs.com)</a>可知：</p><ul><li><code>string</code>类型无法修改其中的某个字符，当我们操作的粒度小到具体1个字符时，用<code>[]byte</code></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>申请一块<code>[]byte</code>的内存，j作为遍历指针</li><li>直接遍历IP地址<ul><li>if  遇到”.”，将”.”更换为 “[“ + “.” + “]”</li></ul></li></ul><p>TIPS：我们注意，IPv4地址一般三个“.”，这里需要在原长度的基础上加6.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n,j := <span class="built_in">len</span>(address), <span class="number">0</span></span><br><span class="line">rets := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n+<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n;i++ &#123;</span><br><span class="line"><span class="keyword">if</span> address[i] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">rets[j]=<span class="string">&#x27;[&#x27;</span></span><br><span class="line">j++</span><br><span class="line">rets[j]=<span class="string">&#x27;.&#x27;</span></span><br><span class="line">j++</span><br><span class="line">rets[j]=<span class="string">&#x27;]&#x27;</span></span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rets[j] = address[i]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(rets)</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1108-IP-地址无效化&quot;&gt;&lt;a href=&quot;#1108-IP-地址无效化&quot; class=&quot;headerlink&quot; title=&quot;1108. IP 地址无效化&quot;&gt;&lt;/a&gt;1108. IP 地址无效化&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/25/golang/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>https://jiac3366.github.io/2021/10/25/golang/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2021-10-25T12:36:56.452Z</published>
    <updated>2021-10-26T13:35:42.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>此题考查堆相关算法的TopK问题<ul><li>1、实现最小堆</li><li>2、遍历所给的数据<ul><li>若堆不满，直接入堆</li><li>若堆满，if 当前当前元素 &gt; 最小堆的root：入堆</li></ul></li><li>3、输出堆中的元素即为TopK的元素</li></ul></li></ul><h2 id="实现堆"><a href="#实现堆" class="headerlink" title="实现堆"></a>实现堆</h2><p>这里简单介绍golang如何实现最小堆，如已掌握可以跳过。题解在最下方。</p><p>官方**<code>&quot;container/heap&quot;</code>**包提供的堆方法（以下<code>Interface1</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface1 <span class="keyword">interface</span> &#123;</span><br><span class="line">   sort.Interface</span><br><span class="line">   Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">   Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而继续点开<code>sort.Interface</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Less reports whether the element with</span></span><br><span class="line"><span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得知，我们需要实现不少方法</p><ul><li><p>总体思路是</p><ul><li>自定义一个数组，数组中需要实现上述2个接口的方法，接口分别是<code>Interface1</code>和<code>Interface2</code>，取名为<strong>PriorityQueue</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">value    <span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">priority <span class="keyword">int</span>    <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line"><span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">index <span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line"><span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">pq[i].index = i</span><br><span class="line">pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*pq)</span><br><span class="line">item := x.(*Item)</span><br><span class="line">item.index = n</span><br><span class="line">*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *pq</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">item := old[n<span class="number">-1</span>]</span><br><span class="line">item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">*pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update modifies the priority and value of an Item in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">item.value = value</span><br><span class="line">item.priority = priority</span><br><span class="line">heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>container/heap</code>堆化、操作<strong>PriorityQueue</strong></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_priorityQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Some items and their priorities.</span></span><br><span class="line">items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line"><span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">pq[i] = &amp;Item&#123;</span><br><span class="line">value:    value,</span><br><span class="line">priority: priority,</span><br><span class="line">index:    i,</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">item := &amp;Item&#123;</span><br><span class="line">value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">priority: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">heap.Push(&amp;pq, item)</span><br><span class="line">pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line"><span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 05:orange 04:pear 03:banana 02:apple</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">100</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">70</span>,<span class="number">2</span>,<span class="number">36</span>,<span class="number">22</span>,<span class="number">5</span>,<span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;\nHeap:&quot;</span>)</span><br><span class="line">heap.Init(h)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;最小值: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//for(Pop)依次输出最小值,则相当于执行了HeapSort</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\nHeap sort:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;347-前-K-个高频元素&quot;&gt;&lt;a href=&quot;#347-前-K-个高频元素&quot; class=&quot;headerlink&quot; title=&quot;347. 前 K 个高频元素&quot;&gt;&lt;/a&gt;347. 前 K 个高频元素&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据备份</title>
    <link href="https://jiac3366.github.io/2021/10/22/mysql_OK/14%20%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>https://jiac3366.github.io/2021/10/22/mysql_OK/14%20%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</id>
    <published>2021-10-21T16:15:16.883Z</published>
    <updated>2021-10-21T16:28:04.331Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>物理备份：收费</p></li><li><p>逻辑备份：</p><ul><li><p>musqldump</p><ul><li><p>备份数据库的表<br>mysqldump -u root -p demo goodsmaster membermaster &gt; test.sql (存的是表信息，恢复时要先有数据库)</p></li><li><p>备份数据库<br>mysqldump -u root -p –databases demo demo1 &gt; test1.sql </p></li><li><p>以一定格式保存和导入数据，</p><ul><li><p>mysql&gt; SELECT * INTO OUTFILE ‘C:/ProgramData/MySQL/MySQL Server 8.0/Uploads/goodsmaster.txt’<br>-&gt; FIELDS TERMINATED BY ‘,’<br>-&gt; LINES TERMINATED BY ‘\n’<br>-&gt; FROM demo.goodsmaster;</p><p>（C:/ProgramData/MySQL/MySQL Server 8.0/Uploads是配置文件 my.ini “secure-file-priv”参数的设定）</p></li><li><p>mysql&gt; LOAD DATA INFILE ‘C:/ProgramData/MySQL/MySQL Server 8.0/Uploads/goodsmaster.txt’<br>-&gt; INTO TABLE demo.goodsmaster<br>-&gt; FIELDS TERMINATED BY ‘,’<br>-&gt; LINES TERMINATED BY ‘\n’;<br>LOAD DATA 速度很快</p></li></ul></li></ul></li></ul></li><li><p>数据恢复工具</p><ul><li><p>mysql 看上一节</p></li><li><p>SOURCE 文件名，要进去mysql再执行</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;物理备份：收费&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑备份：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;musqldump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;备份数据库的表&lt;br&gt;mysqldump -u root -p demo goodsmaster member</summary>
      
    
    
    
    <category term="MySQL必知必会" scheme="https://jiac3366.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>日志</title>
    <link href="https://jiac3366.github.io/2021/10/22/mysql_OK/13%20%E6%97%A5%E5%BF%97/"/>
    <id>https://jiac3366.github.io/2021/10/22/mysql_OK/13%20%E6%97%A5%E5%BF%97/</id>
    <published>2021-10-21T16:15:16.882Z</published>
    <updated>2021-10-21T16:15:16.883Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>MySQL 日志包括通用查询日志、慢查询日志、错误日志、二进制日志、中继日志、重做日志和回滚日志</p><ul><li>通用查询日志<br>记录了所有用户的连接开始时间和截止时间，以及发给 MySQL 数据库服务器的所有 SQL 指令，<strong>还原操作时的具体场景</strong>，帮助我们了解操作发生的具体时间和操作的细节<ul><li>show variables like ‘%general%’;<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211014132742404.1c3b41tazw1s.png" alt="image-20211014132742404"></li><li>SET GLOBAL general_log = ‘ON’; </li><li>SET @@global.general_log_file = ‘mytest.log’;</li></ul></li><li>慢查询日志<ul><li>show variables like ‘min%’;</li><li>long_query_time=10 和 min_examined_row_limit=0 共同判断：只要查询时间和扫描行数大于这2值就记录慢日志</li></ul></li><li>错误日志（排障首选）<ul><li>错误日志文件中记录了服务器启动的时间，以及存储引擎 InnoDB 启动和停止的时间等。</li><li>默认是开启，可以在mysql配置文件“my.ini”中配置</li></ul></li><li>二进制日志<br>记录数据库的更新事件<ul><li>查询和删除：<ul><li>正在写入的二进制日志<ul><li>SHOW MASTER STATUS;</li></ul></li><li>所有的二进制日志<ul><li>SHOW BINARY LOGS;</li></ul></li><li>二进制日志中所有数据更新事件:<ul><li>SHOW BINLOG EVENTS IN 二进制文件名; ???</li></ul></li><li>重新开一个新的日志文件记录binlog<ul><li>FLUSH BINARY LOGS;</li></ul></li><li>删除<ul><li>RESET MASTER; </li><li>删除比指定二进制日志文件编号小的所有二进制日志文件<ul><li>SQL：PURGE MASTER LOGS TO ‘GJTECH-PC-bin.000005’; </li></ul></li></ul></li></ul></li><li>利用mysqldump和binlog恢复数据<ul><li>1、数据库外执行：mysqldump -u root -p album &gt; newbackup.sql（还可以-h指定数据服务器名称）</li><li>2、flush binary logs</li><li>3、发生宕机，检查确定要哪些binlog，因为超过系统变量 max_binlog_size 指定的值时，系统就会生成一个新的二进制日志文件)</li><li>4、flush binary logs，与上一条刷新log对应组成的作用是，独立保留下全量备份到宕机时段的binlog文件，是防止后面数据恢复的事件被写入最新的二进制日志文件，妨碍理解文件的内容。</li><li>5、重建DB，</li><li>6、数据库外执行：mysql -u root -p django_album &lt; newbackup.sql  <strong>这时全量备份已恢复</strong></li><li>7、show binlog events in ‘binlog.000007’;  查看找到最新的begin起始位置？这里假设是318</li><li>8、数据库外执行：mysqlbinlog –start-position=318 “/var/lib/mysql/binlog.000007” | mysql -u root -p<br>mysqlbinlog –start-positon=xxx –end-position=yyy 二进制文件名 | mysql -u 用户 -p</li></ul></li></ul></li><li>中继日志<ul><li>主从架构中，为了与主服务器保持一致，要把主服务器的二进制日志写入到从服务器本地的日志，这个日志文件叫中继日志，格式：从服务器名-relay-bin. 序号.</li><li>有坑：中继日志里包含主从服务器的host，重装系统记得改回之前的host</li></ul></li><li>回滚日志 undo log<ul><li>用于事务回滚</li><li>使其他事务读取到这个事务修改数据前的值</li><li>默认大小1G<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211019103346389.5b3w5bn9ay00.png" alt="image-20211019103346389"></li><li>下列变量定义了回滚日志所在的文件夹、是否加密、是否自动截断回收空间（有效的前提是设置了独立表空间）和是否有独立的表空间（放单独一个文件的意思？）<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211019104331359.4usr2rtimf40.png" alt="image-20211019103346389"></li></ul></li><li>重做日志 redolog<ul><li>系统遇到故障的恢复过程中，可以修复被未完成的事务修改的数据.</li><li>宕机或者停电等异常情况导致内存保存的数据更新操作丢失，可以通过读取重做日志中记录的数据更新操作，把没来得及写到磁盘上的数据更新写到磁盘上，确保数据的完整性.</li><li>SHOW VARIABLES LIKE ‘%innodb_log_files_in_group%’ 查看重做日志的数量，取值为1-4，用于记录不同的操作<ul><li>1 用户创建表的插入操作</li><li>2  用户创建表的更新和删除操作</li><li>3 临时表的插入操作</li><li>4 临时表的更新和删除操作</li></ul></li></ul></li></ul></li><li><p>总结：</p><ul><li>二进制日志：增量信息，分库分表场景很麻烦，难以确定起止位置，解决方案可以是配置主从架构，靠中继日志在从DB备份</li><li>中继日志：从服务器用来存放主服务器二进制日志内容的一个中间文件，用于同步主服务器数据</li><li>回滚日志？：存事务数据更新前的状态，以便回滚</li><li>重做日志：是为了确保数值持久性、防止数据更新丢失的一种日志</li></ul></li><li><p>课后习题：</p><ul><li><p>mysql&gt; SHOW BINLOG EVENTS IN ‘GJTECH-PC-bin.000013’;<br>+———————-+——+—————-+———–+————-+————————————–+<br>| Log_name             | Pos  | Event_type     | Server_id | End_log_pos | Info                                 |<br>+———————-+——+—————-+———–+————-+————————————–+<br>| GJTECH-PC-bin.000013 |  556 | Query          |         1 |         627 | BEGIN                                |<br>| GJTECH-PC-bin.000013 |  627 | Table_map      |         1 |         696 | table_id: 114 (demo.goodsmaster)     |<br>| GJTECH-PC-bin.000013 |  696 | Delete_rows    |         1 |         773 | table_id: 114 flags: STMT_END_F      |<br>| GJTECH-PC-bin.000013 |  773 | Xid            |         1 |         804 | COMMIT /* xid=253 <em>/                 |<br>| GJTECH-PC-bin.000013 |  804 | Anonymous_Gtid |         1 |         894 | SET @@SESSION.GTID_NEXT= ‘ANONYMOUS’ |<br>| GJTECH-PC-bin.000013 |  894 | Query          |         1 |         969 | BEGIN                                |<br>| GJTECH-PC-bin.000013 |  969 | Table_map      |         1 |        1038 | table_id: 114 (demo.goodsmaster)     |<br>| GJTECH-PC-bin.000013 | 1038 | Write_rows     |         1 |        1094 | table_id: 114 flags: STMT_END_F      |<br>| GJTECH-PC-bin.000013 | 1094 | Xid            |         1 |        1125 | COMMIT /</em> xid=259 */                 |</p></li><li><p>其中包括了哪几个 SQL 数据操作呢？为了从二进制日志中恢复这些操作，我们应该如何设置起始位置和截止位置呢？<br>A:这段二进制日志包括了2个SQL操作，第一个是从数据表demo.goodsmaster中删除一条记录，第二个是向数据表demo.goodsmaster中插入一条记录。起始位置：627，截止位置：1125</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MySQL 日志包括通用查询日志、慢查询日志、错误日志、二进制日志、中继日志、重做日志和回滚日志&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通用查询日志&lt;br&gt;记录了所有用户的连接开始时间和截止时间，以及发给 MySQL 数据库服务器的所有 SQL 指令，&lt;strong&gt;</summary>
      
    
    
    
    <category term="MySQL必知必会" scheme="https://jiac3366.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>数学计算 字符串处理</title>
    <link href="https://jiac3366.github.io/2021/10/20/mysql_OK/9%20%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>https://jiac3366.github.io/2021/10/20/mysql_OK/9%20%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</id>
    <published>2021-10-20T00:53:21.034Z</published>
    <updated>2021-10-20T00:53:21.035Z</updated>
    
    <content type="html"><![CDATA[<ul><li>大部分 DBMS 会有自己特定的函数，SQL 函数的代码可移植性很差</li><li>数学函数<ul><li>向上取整 CEIL(X) 和 CEILING(X)</li><li>向下取整 FLOOR(X)</li><li>舍入函数 ROUND(X,D)<br>ROUND(X) 表示保留 0 位小数。</li><li><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211011181545414.10it0i2wmqwg.png" alt="image-20211011181545414"></li></ul></li><li>字符串函数<ul><li>使用示例查看10.<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211011180904921.2oguam3qxag0.png" alt="image-20211011180904921"></li><li><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211011181442676.1a19hti7n58g.png" alt="image-20211011181445092"></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;大部分 DBMS 会有自己特定的函数，SQL 函数的代码可移植性很差&lt;/li&gt;
&lt;li&gt;数学函数&lt;ul&gt;
&lt;li&gt;向上取整 CEIL(X) 和 CEILING(X)&lt;/li&gt;
&lt;li&gt;向下取整 FLOOR(X)&lt;/li&gt;
&lt;li&gt;舍入函数 ROUND(X,D)&lt;</summary>
      
    
    
    
    <category term="MySQL必知必会" scheme="https://jiac3366.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>时间函数</title>
    <link href="https://jiac3366.github.io/2021/10/20/mysql_OK/8%20%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://jiac3366.github.io/2021/10/20/mysql_OK/8%20%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-20T00:53:21.033Z</published>
    <updated>2021-10-20T00:53:21.033Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>很多人把时间日期的相关计算放到编程语言层面去处理</p></li><li><p><strong>获取日期时间数据中部分信息的函数</strong><br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211011094123935.2ig4efowa8a0.png" alt="image-20211011094129105"></p></li></ul><ul><li><p>需求：统计一天中每小时的销售数量和销售金额<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211011092429576.4s7zyrk5fwq0.png" alt="image-20211011092429576"></p><p>第2行也可以改成 HOUR(b.transdate) AS 时段,过程如下：</p><ul><li>从交易时间中抽取小时信息：EXTRACT(HOUR FROM b.transdate)；</li><li>按交易的小时信息分组；</li><li> 按分组统计销售数量和销售金额的和；</li><li>按交易的小时信息排序。</li></ul></li><li><p><strong>计算日期时间的函数</strong></p><ul><li><p>DATE_ADD（date, INTERVAL 表达式 type）</p><p>DATE_ADD() 来计算从某个时间点开始，过去或者未来一个时间间隔的时间<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211011095104770.10daidmreink.png" alt="image-20211011095104770"></p></li><li><p>LAST_DAY（date）<br>获得某个时间节点当月的最后一天的日期</p></li><li><p>eg:今天是 2020 年 12 月 10 日，计算与去年同期相比的增长率<br>从2020.12.10到2019.12.01——SELECT</p><pre><code>DATE_ADD( LAST_DAY( DATE_ADD( DATE_ADD( &#39;2020-12-10&#39;, INTERVAL - 1 YEAR ), INTERVAL - 1 MONTH )), INTERVAL 1 DAY );</code></pre></li></ul></li><li><p><strong>其他日期时间函数</strong></p><ul><li>获取当前的日期：CURDATE（）</li><li>把日期按照一定的格式显示： DATE_FORMAT(date, %xx) ,xx有很多种格式</li><li> DATEDIFF（date1,date2），表示日期“date1”与日期“date2”之间差几天。</li><li>获取日期“date”是周几：DAYOFWEEK（date）<ul><li><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211011101930441.20oi03o1s4xs.png" alt="image-20211011101930441"><br>SELECT<pre><code>CASE DAYOFWEEK(CURDATE()) - 1    WHEN 0 THEN        7    ELSE        DAYOFWEEK(CURDATE()) - 1END CASE;</code></pre></li></ul></li><li></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很多人把时间日期的相关计算放到编程语言层面去处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;获取日期时间数据中部分信息的函数&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/jiac3366/im</summary>
      
    
    
    
    <category term="MySQL必知必会" scheme="https://jiac3366.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>聚合函数</title>
    <link href="https://jiac3366.github.io/2021/10/20/mysql_OK/7%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
    <id>https://jiac3366.github.io/2021/10/20/mysql_OK/7%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-20T00:53:21.032Z</published>
    <updated>2021-10-21T16:23:31.008Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>MAX（）和 MIN（）计算出的结果不一定是同一条记录的数据</p></li><li><p>COUNT( )</p><ul><li>如果 COUNT（*）与 GROUP BY 一起使用，就表示统计分组内有多少条数据。它也可以单独使用，这就相当于数据集全体是一个分组，统计全部数据集的记录数</li><li>COUNT（字段）用来统计分组内这个字段的值(非空值)出现了多少次。如果字段值是空，就不统计。<br>使用场景：统计表中字段的非空值</li></ul></li><li><p>课后：</p><ul><li><p>在商品信息表中，哪种商品的商品名称有重复，分别重复了几次？</p></li><li><p>select </p><pre><code>COUNT(column_name) as column_as from table_name group by column_as having now_count&gt;1;</code></pre></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MAX（）和 MIN（）计算出的结果不一定是同一条记录的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;COUNT( )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 COUNT（*）与 GROUP BY 一起使用，就表示统计分组内有多少条数据。它也可以单独使用，这就相当于数据</summary>
      
    
    
    
    <category term="MySQL必知必会" scheme="https://jiac3366.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>WHERE和HAVING</title>
    <link href="https://jiac3366.github.io/2021/10/20/mysql_OK/6WHERE%E5%92%8CHAVING/"/>
    <id>https://jiac3366.github.io/2021/10/20/mysql_OK/6WHERE%E5%92%8CHAVING/</id>
    <published>2021-10-20T00:53:21.031Z</published>
    <updated>2021-10-20T00:53:21.031Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>需要查询出一个商品记录集，限定条件是单笔销售金额超过 50 元–&gt;2者结果一样<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211007164836324.c21mvdf6vdc.png" alt="image-20211007164836324"></p></li><li><p>WHERE——先从数据表 demo.transactiondetails 中抽取满足条件“a.salesvalue&gt;50，然后连接goodsmaster，再DISTINCT<br>也就是先限定金额&gt;50的流水，再把商品名字加过去</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211007154739645.6a3jjqb8k180.png" alt="image-20211007154747965"></p></li><li><p>HAVING查询过程——</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211007165751197.3jutbianj3i0.png" alt="image-20211007165757837"></p><ul><li>先把有关的信息从关联表都连接好</li><li>对数据集进行分组，形成一个包含所有需要的信息的数据集合</li><li>通过 HAVING 条件的对集合筛选，得到需要的数据</li></ul></li><li><p>WHERE和HAVING区别：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。</p><ul><li><p>WHERE 比 HAVING 更高效</p></li><li><p>HAVING 必须要与 GROUP BY 配合使用，特点是可以把分组计算的函数作为筛选条件，而WHERE运行在GROUP BY前，它无法做到这样的查询。</p></li><li><p>2者不互斥——要查询“2020-12-10”和“2020-12-11”这两天收银金额超过 100 元的销售日期、收银员名称、销售数量和销售金额。</p><p><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211007171728111.oqx293qoxy8.png" alt="image-20211007171731122"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要查询出一个商品记录集，限定条件是单笔销售金额超过 50 元–&amp;gt;2者结果一样&lt;br&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/im</summary>
      
    
    
    
    <category term="MySQL必知必会" scheme="https://jiac3366.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>外键与连接</title>
    <link href="https://jiac3366.github.io/2021/10/20/mysql_OK/5%E5%A4%96%E9%94%AE%E5%92%8C%E8%BF%9E%E6%8E%A5/"/>
    <id>https://jiac3366.github.io/2021/10/20/mysql_OK/5%E5%A4%96%E9%94%AE%E5%92%8C%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-10-20T00:53:21.029Z</published>
    <updated>2021-10-20T00:53:21.030Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>在 MySQL 中，外键是通过外键约束来定义的。外键约束就是约束的一种，它必须在从表</p><p>中定义，包括指明哪个是外键字段，以及外键字段所引用的主表中的主键字段是什么。</p><p>MySQL 若发现要删除的主表记录正在被从表中某条记录的外键字段所引用，就会提示错误</p></li><li><p>用到 MySQL 自带的、用于存储系统信息的数据库：information_schema。我们可以查看外键约束的相关信息<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211007145129342.5y01bkthbc40.png" alt="image-20211007145129342"></p><ul><li>创建外键约束<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211007145301398.1zk4o9o4n6xs.png" alt="image-20211007145301398"></li><li>修改表定义外键约束<br>ALTER TABLE 从表名 ADD CONSTRAINT 约束名 FOREIGN KEY 字段名 REFERENCES 主表名 （字段名）</li></ul></li><li><p>外键约束不是关联查询的必要条件，MySQL 允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑，提高性能。但是有了它，MySQL 系统会保护你的数据，避免出现误删的情况，从而提高系统整体的可靠性。（进货数据拆成了 2 个表，这就决定了无论是数据添加，还是数据删除，都不能通过一条 SQL 语句实现，完全有可能只执行了一部分）</p></li><li><p>课后：<br><img src="https://cdn.jsdelivr.net/gh/jiac3366/image-host@master/mysqlbizhbihui/image-20211007152542372.2mwtcw6udcm0.png" alt="image-20211007152545535"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 MySQL 中，外键是通过外键约束来定义的。外键约束就是约束的一种，它必须在从表&lt;/p&gt;
&lt;p&gt;中定义，包括指明哪个是外键字段，以及外键字段所引用的主表中的主键字段是什么。&lt;/p&gt;
&lt;p&gt;MySQL 若发现要删除的主表记录正在被从表中某条记录的外键字段</summary>
      
    
    
    
    <category term="MySQL必知必会" scheme="https://jiac3366.github.io/categories/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://jiac3366.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiac3366.github.io/"/>
  <updated>2021-10-04T04:35:42.350Z</updated>
  <id>https://jiac3366.github.io/</id>
  
  <author>
    <name>Jiaccc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-10-04T04:27:46.744Z</published>
    <updated>2021-10-04T04:35:42.350Z</updated>
    
    <content type="html"><![CDATA[<p>线程同步</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;线程同步&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2021-10-04T04:27:43.200Z</published>
    <updated>2021-10-04T04:27:43.367Z</updated>
    
    <content type="html"><![CDATA[<ul><li>忙等待锁-自旋锁<ul><li>当获取不到锁时，线程就会⼀直 wile 循环，不做任何事情，所以就被称为「忙等待锁」，也被称 为⾃旋锁<br>这是最简单的⼀种锁，⼀直⾃旋，利⽤ CPU 周期（占用着CPU），直到锁可⽤。在单处理器上，需要抢占式的调度器（即 不断通过时钟中断⼀个线程，运⾏其他线程）。否则，⾃旋锁在单 CPU 上⽆法使⽤，因为⼀个⾃旋的线程 永远不会放弃 CPU。？</li></ul></li><li>无等待锁<ul><li>当没获取到锁的时候，就把当前线程放⼊到锁的等待队列，然后执⾏调度程序，把 CPU 让给其他线程执⾏</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;忙等待锁-自旋锁&lt;ul&gt;
&lt;li&gt;当获取不到锁时，线程就会⼀直 wile 循环，不做任何事情，所以就被称为「忙等待锁」，也被称 为⾃旋锁&lt;br&gt;这是最简单的⼀种锁，⼀直⾃旋，利⽤ CPU 周期（占用着CPU），直到锁可⽤。在单处理器上，需要抢占式的调度器（即 不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP的缓存代理</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86/</id>
    <published>2021-10-04T03:11:25.120Z</published>
    <updated>2021-10-04T08:14:38.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP的缓存代理"><a href="#HTTP的缓存代理" class="headerlink" title="HTTP的缓存代理"></a>HTTP的缓存代理</h2><p>HTTP缓存功能主要由proxy server实现</p><ul><li><p><strong>client和proxy缓存控制的区别</strong><br>因为proxy server面对多client，所以origin server要对他作多点限制</p><ul><li>区别是客户端or代理的缓存<ul><li>若是客户端，用<code>cache-control: private</code>标识</li><li>若是代理，用<code>cache-control: public</code></li></ul></li><li>区别cache验证的字段<ul><li>代理使用<code>proxy_revalidate</code>而不是<code>must_revalidate</code>,要求代理的缓存过期后回源server验证，client不回源</li></ul></li><li>区别cache生存时间字段<ul><li>使用<code>s-maxage</code>限定缓存在代理上能存多久，client仍然使用<code>max-age</code></li></ul></li><li>代理专属属性：<code>no-transform</code>，不准对缓存的数据做任何手脚，甚至是优化</li><li>详细请看20/21的流程图</li></ul></li><li><p>客户端的缓存控制补充</p><ul><li><code>max-stale=3</code>: 废旧度要小于3天，至多max-age过期3天还能使用</li><li><code>min-fresh=4</code>: 新鲜度要大于4天，max-age前4天内都不使用</li><li><code>only-if-cached</code>: 只接受代理的缓存，不接受源</li></ul></li><li><p>代理如何知道改次请求是否与上次的请求匹配</p><ul><li>vary字段——“<code>vary</code>字段记录下一些字段，这些字段是响应这个请求结果的依据”，所以代理收到带vary会提取里面的请求头计算hash，存入缓存或与已有的缓存作匹配</li></ul></li><li><p>删除URI对应的缓存数据</p><ul><li>自定义请求方法“PURGE”发给代理（?）</li></ul></li><li><p>试着自己画出缓存的流程图</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP的缓存代理&quot;&gt;&lt;a href=&quot;#HTTP的缓存代理&quot; class=&quot;headerlink&quot; title=&quot;HTTP的缓存代理&quot;&gt;&lt;/a&gt;HTTP的缓存代理&lt;/h2&gt;&lt;p&gt;HTTP缓存功能主要由proxy server实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP的代理服务</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-10-04T02:46:13.762Z</published>
    <updated>2021-10-04T08:14:34.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP的代理服务"><a href="#HTTP的代理服务" class="headerlink" title="HTTP的代理服务"></a>HTTP的代理服务</h2><ul><li>代理头字段：Via（请求头/响应头都有）<ul><li>谁转发了报文，就在报文的Via字段接着加上自己的IP?</li></ul></li><li><code>X-Forwarded-For</code>和<code>X-Real-IP</code><br>若只有1层代理，2个字段一样<ul><li>X-Forwarded-For追加的是请求方的IP——“为谁而转发”，最左边的即为client的IP</li><li>X-Real-IP只记录client的IP</li></ul></li><li>X-Forwarded要修改HTTP内容，性能低下，且在HTTPS中不能实现</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP的代理服务&quot;&gt;&lt;a href=&quot;#HTTP的代理服务&quot; class=&quot;headerlink&quot; title=&quot;HTTP的代理服务&quot;&gt;&lt;/a&gt;HTTP的代理服务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代理头字段：Via（请求头/响应头都有）&lt;ul&gt;
&lt;li&gt;谁转发了报文，</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>Cookie</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/Cookie/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/Cookie/</id>
    <published>2021-10-04T01:37:19.327Z</published>
    <updated>2021-10-04T08:14:29.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul><li><p>Cookie有效期用Expires, Max-Age属性设置<br>server过于健忘，有时会设多条cookie，用“；”分隔</p></li><li><p><code>Expires</code>和<code>Max-Age</code></p><ul><li>Expires为截止日期，是个绝对时间，如果更改本机时间可能会造成失效.</li><li>Max-Age+报文收到的时间即等于失效时间，优先使用</li></ul></li><li><p><code>Domain</code>和<code>Path</code>组成Cookie作用域<br>让client发送Cookie给指定URI(?)</p><ul><li>Domain指定所属域</li><li>Path指定路径，一般用”/“，代表域名所有的路径都使用</li></ul></li><li><p><code>HttpOnly</code></p><ul><li>防止客户端使用非HTTP方式 (例如Js) 获取Cookie——预防XSS</li></ul></li><li><p><code>SameSite</code>:value（?）<br>可以防XSRF</p><ul><li>值为Strict：不能随跳转URI跨站发送</li><li>值为Lax：允许GET/HEAD等安全方法，但禁止POST跨站发送</li></ul></li><li><p><code>Secure</code></p><ul><li>仅能用HTTPS传输Cookie，但Cookie在Browser明文存在</li></ul></li><li><p>Cookie最大作用：身份识别-广告追踪</p><ul><li>google给你贴个Cookie，别的网站通过读取它的Cookie（第三方Cookie）对你推广告</li></ul></li><li><p>会话Cookie</p><ul><li>不设置<code>Expires</code>和<code>Max-Age</code>，浏览器一关就失效，过期时间显示为“session”或“N/A”</li><li>Cookie大小&lt;=4k，以数据库记录(sqlite)存放</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cookie有效期用Expires, Max-Age属性设置&lt;br&gt;server过于健忘，</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>重定向和跳转</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC/</id>
    <published>2021-10-04T01:18:14.240Z</published>
    <updated>2021-10-04T08:14:25.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重定向和跳转"><a href="#重定向和跳转" class="headerlink" title="重定向和跳转"></a>重定向和跳转</h2><p>响应报文中有字段：Location: [URI]</p><ul><li>301永久重定向：意味着原URI不再存在了，今后必须用新的URI，浏览器可能会更新书签等，爬虫也会更新</li><li>302临时重定向：浏览器和爬虫会认为临时不可用原URI，执行简单跳转</li><li>303.307.308类似，但有细节上的约束，慎用！</li><li><strong>重定向是server控制浏览器的手段</strong><ul><li>域名更换/网站维护等避免404出现</li><li>增加多个类似的域名入口再跳到主站点</li></ul></li><li>重定向场景<ul><li>301-涉及到重大改变的，对SEO也挺重要</li><li>302-涉及到临时维护跳转到通知页或服务降级（双十一促销）</li></ul></li><li>一个跳转会有2次“请求-应答”(?)</li><li>浏览器的前进和后退——跳转重定向（?）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重定向和跳转&quot;&gt;&lt;a href=&quot;#重定向和跳转&quot; class=&quot;headerlink&quot; title=&quot;重定向和跳转&quot;&gt;&lt;/a&gt;重定向和跳转&lt;/h2&gt;&lt;p&gt;响应报文中有字段：Location: [URI]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;301永久重定向：意味着原URI</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP连接管理</title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</id>
    <published>2021-10-03T05:07:24.334Z</published>
    <updated>2021-10-04T08:14:46.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP连接管理"><a href="#HTTP连接管理" class="headerlink" title="HTTP连接管理"></a>HTTP连接管理</h2><ul><li><p>长连接<code>Connection:&quot;Keep-alive&quot;</code><br>长连接：第一次请求后的请求复用第1次请求打开的TCP连接</p><ul><li>1.1默认启用长连接,client发送<code>Connection:&quot;Keep-alive&quot;</code>表示使用长连接，但server不会管这么多只要支持就发这字段.</li><li>server一般不主动关闭连接，可以设置Nginx的策略关闭<ul><li><code>keepalive_timeout</code> 超时时间</li><li><code>keepalive_requests</code> 长连接可发的最大请求数</li></ul></li></ul></li><li><p>如何优化缓解HTTP1.1队头阻塞——“请求-应答模型导致”<br>类似上班打卡，只要有一个人打不上卡，后面都等着</p><ul><li>“并发连接”（买多几台打卡机）=&gt;client同时对1server发起多个长连接，一般一个client最多并发6~8个长连接</li><li>“域名分片”（前台放不下这么多打卡机，在每个楼层放吧），本质上也是数量解决，HTTP对一个域名并发有限制(?)，那就多开几个域名，绑定到同一个服务器</li></ul></li><li><p>PS：</p><ul><li>长连接最重要是区分多个报文的开始和结束，使用<code>Content-Length</code>正确标记报文结束。对于流式传输，必须用分块传输编码(<code>Transfer-Encoding:chunked</code>?)</li><li><code>Connection:Upgrade + 状态码101</code>表示协议升级表示从HTTP切换到WebSocket</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP连接管理&quot;&gt;&lt;a href=&quot;#HTTP连接管理&quot; class=&quot;headerlink&quot; title=&quot;HTTP连接管理&quot;&gt;&lt;/a&gt;HTTP连接管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;长连接&lt;code&gt;Connection:&amp;quot;Keep-alive&amp;</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型与编码</title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81/</id>
    <published>2021-10-03T04:41:00.843Z</published>
    <updated>2021-10-04T08:14:22.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型与编码"><a href="#数据类型与编码" class="headerlink" title="数据类型与编码"></a>数据类型与编码</h2><ul><li><p>数据类型与编码</p><p>HTTP告诉上层应用这是什么数据——数据类型、压缩格式</p><ul><li><p>MIME数据类型</p></li><li><p>压缩格式</p><ul><li><p>gzip(GUN zip压缩格式 最流行)</p><p>Nginx gzip on仅仅对文本数据有效</p></li><li><p>deflate(zlib压缩格式)</p></li><li><p>br(专门HTTP优化的压缩算法)</p></li></ul></li><li><p>相关字段（<strong>Accept-xxx代表想要对方要干的，Content-xxx代表自己是这么干的</strong>）</p><ul><li><p><code>Accept</code>(client告诉server可接受的MIME类型)</p></li><li><p><code>Content-Type</code>（server告诉client实际发了啥MIME）</p><p>eg: text/html; charset=utf-8</p></li><li><p><code>Accept-Encoding</code>（client支持的压缩格式）</p></li><li><p><code>Content-Encoding</code>（server实际用的压缩格式）</p><p>以上2个不发说明 client不支持压缩 server也没有压缩</p></li></ul></li></ul></li><li><p>语言类型与编码</p><p>浏览器能解析多种数据类型，但又如何让它显示成不同国家的自然语言呢？</p><ul><li><p>相关字段</p><ul><li><p><code>Accept-Language</code></p><p>type-subtype:en-GB, en-US, zh-CN</p></li><li><p>Content-Language(少用)</p></li><li><p>Accept-Charset(少用)</p></li><li><p>注意：没有Content-Charset</p><p>“Content-Charset”相关内容在<code>Content-Type</code>（server告诉client实际发了啥MIME）</p></li></ul></li></ul></li><li><p>内容协商优先级</p><ul><li><p>分号权重比逗号低</p><ul><li>  <img src="https://api2.mubu.com/v3/document_image/0386cf82-829e-41ae-b4dd-474bcfa3874b-12600127.jpg"></li></ul></li></ul></li><li><p>服务器响应的结果</p><ul><li>  使用<code>vary</code>字段记录响应这个请求结果的依据</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据类型与编码&quot;&gt;&lt;a href=&quot;#数据类型与编码&quot; class=&quot;headerlink&quot; title=&quot;数据类型与编码&quot;&gt;&lt;/a&gt;数据类型与编码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据类型与编码&lt;/p&gt;
&lt;p&gt;HTTP告诉上层应用这是什么数据——数据类型、压缩格</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/1%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/1%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-10-03T03:32:56.814Z</published>
    <updated>2021-10-04T03:32:22.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="透视HTTP协议"><a href="#透视HTTP协议" class="headerlink" title="透视HTTP协议"></a>透视HTTP协议</h2><ul><li>HTTP1.1缺点<ul><li>请求-应答模式，会造成同步阻塞    </li><li>以文本格式传输Header，效率下降</li></ul></li><li><a href="./%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81.md">数据类型与编码</a></li><li><a href="./HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6.md">HTTP传输大文件</a></li><li><a href="./HTTP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.md">HTTP连接管理</a></li><li><a href="./%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC.md">重定向和跳转</a></li><li><a href="./Cookie.md">Cookie</a></li><li><a href="./HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6.md">HTTP的缓存控制</a></li><li><a href="./HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.md">HTTP的代理服务</a></li><li><a href="./HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86.md">HTTP的缓存代理</a></li><li>HTTPS</li><li>对称与非对称加密</li><li>数字签名与证书</li><li>…</li><li>HTTP2特性概览</li><li>HTTP3展望</li><li>Nginx、OpenResty</li><li>WAF</li><li>CDN</li><li>Websocket：沙盒里的TCP</li><li>HTTP性能优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;透视HTTP协议&quot;&gt;&lt;a href=&quot;#透视HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;透视HTTP协议&quot;&gt;&lt;/a&gt;透视HTTP协议&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP1.1缺点&lt;ul&gt;
&lt;li&gt;请求-应答模式，会造成同步阻塞    &lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP传输大文件</title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-03T03:09:44.579Z</published>
    <updated>2021-10-04T08:14:32.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP传输大文件"><a href="#HTTP传输大文件" class="headerlink" title="HTTP传输大文件"></a>HTTP传输大文件</h2><ul><li><p>Transfer-Encoding与Content-Length互斥</p><p>在响应头部<code>Transfer-Encoding:chunked</code>表示</p></li><li><p>交互流程：</p><ul><li>Server用<code>Accept-Ranges:bytes</code>告知client支持范围请求（视频快进功能）<br>不支持干脆不发</li><li>client使用<code>Range:bytes=x-y</code> 告知要的范围<br>eg:一个100字节文件, client要前10字节：Range:bytes=0-10</li><li>server收到Range字段后先检查合法性：非法返416，合法返206，并在头字段加<code>Content-Range:byes=x-y</code></li><li>client也可以一次性请求多个范围，响应报文数据类型字段为<code>multipart/byteranges</code>表示响应报文体由多段字节序列组成<ul><li>多段序列报文的格式与分块传输有一点区别</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP传输大文件&quot;&gt;&lt;a href=&quot;#HTTP传输大文件&quot; class=&quot;headerlink&quot; title=&quot;HTTP传输大文件&quot;&gt;&lt;/a&gt;HTTP传输大文件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Transfer-Encoding与Content-Length互</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="https://jiac3366.github.io/2021/09/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://jiac3366.github.io/2021/09/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2021-09-15T14:56:09.563Z</published>
    <updated>2021-09-15T14:56:58.773Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>  进程间通信</p><ul><li><p>  管道</p><p>  通信⽅式效率低，不适合进程间频繁地交换数据，匿名管道跟随进程的生命周期<br>  在 shell ⾥⾯执⾏ A | B 命令的时候，A 进程和 B 进程都是 shell<br>  创建出来的⼦进程<br>  如果要进程双向通信，要创建2个管道（不然父进程fork子进程也把管道读写描述符复制了，2者对同一个管道写读造成混乱）<br>  ​进程写⼊读取的数据都经过内核</p><ul><li><p>  | 匿名管道 特殊文件 在内存</p></li><li><p>  mkfifo myPipe 创建命名管道<br>  ls在文件系统能看到文件类型是p(pipe)</p></li></ul></li><li><p>  消息队列</p><p>  相比管道，可以频繁交换数据<br>  ​消息队列跟随内核的生命周期，会有两个宏定义 MSGMAX 和 MSGMNB<br>  ，它们以字节为单位，分别定义了⼀条消息的最⼤⻓度和⼀个队列的最⼤⻓度</p><ul><li><p>  缺点：⼀是通信不及时，二不适合⽐较⼤数据的传输，三存在⽤户态与内核态之间的数据拷⻉开销</p></li></ul></li><li><p>  共享内存</p><p>  拿出⼀块虚拟地址空间来，映射到相同的物理内存中</p></li><li><p>  信号量(p191)</p><p>  防⽌多进程竞争共享资源造成的数据错乱的保护机制，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。</p><ul><li><p>  信号初始化为 1 ，是互斥信号量</p><p>  在任何时刻只有⼀个进程在访问</p></li><li><p>  信号初始化为 10，是同步信号量</p><p>  保证进程 A 应在进程 B 之前执⾏</p></li></ul></li><li><p>  信号</p><p>  进程间通信机制中唯⼀的异步通信机制</p><ul><li><p>  Ctrl+C 产⽣ SIGINT 信号，表示终⽌该进程</p></li><li><p>  Ctrl+Z 产⽣ SIGTSTP 信号，表示停⽌该进程，但还未结束</p></li></ul></li><li><p>  Socket</p><p>  Socket<br>  通信不仅可以跨⽹络与不同主机的进程间通信，还可以在同主机上进程间通信</p><ul><li><p>  UDP 是没有连接的，不需要调⽤ listen 和 connect，要bind</p></li><li><p>  socket类型:6种（协议族：本机/Ipv4/Ipv6，通信特性：字节流/数据报）</p><p>  本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像<br>  TCP 和 UDP 要绑定 IP<br>  地址和端⼝，⽽是绑定⼀个本地⽂件，这也就是它们之间的最⼤区别。</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;  进程间通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;  管道&lt;/p&gt;
&lt;p&gt;  通信⽅式效率低，不适合进程间频繁地交换数据，匿名管道跟随进程的生命周期&lt;br&gt;  在 shell ⾥⾯执⾏ A | B 命令的时候，A 进程和 B 进程都是 shell&lt;br&gt;  </summary>
      
    
    
    
    <category term="操作系统" scheme="https://jiac3366.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>后端知识</title>
    <link href="https://jiac3366.github.io/2021/08/14/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86/"/>
    <id>https://jiac3366.github.io/2021/08/14/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86/</id>
    <published>2021-08-14T10:09:16.833Z</published>
    <updated>2021-09-15T14:53:37.756Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>  CAP理论</p><p>  不关注单节点系统，也不关注没有数据共享的多节点系统</p></li><li><p>  事务的ACID特性（AD必须要保证）</p><ul><li><p>  A 原子性 C 一致性 I 隔离性 D 持久性</p><p>  C 有流水就有余额变化 I 没提交的事务对于其他事务不可见</p></li><li><p>  实现：（不可能100%实现ACID）</p><ul><li><p>  数据库事务——四个隔离级别</p><ul><li><ul><li>  <img src="https://api2.mubu.com/v3/document_image/6fb862fc-6616-4f05-afd9-6cacca8bd2f0-12600127.jpg"></li></ul></li><li><p>  区分RC(读提交)和RR(可重复读)——一个事务能否读到其他事务对数据已提交的更新</p><ul><li><p>  能： RC、不能：RR（mysql默认）</p></li><li><p>  幻读很少遇到也基本不会影响数据准确性</p><p>  RR屏蔽掉了其他事务对真实数据的修改，自己无法查询，但实际上数据已存在或已经修改</p></li><li><p>  兼顾【性能、并发、一致性】的交易方案：</p><ul><li><p>  1、给账户余额表增加一个 log_id<br>  属性，记录最后一笔交易的流水号</p></li><li><p>  2、首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号</p></li><li><p>  3、然后写入流水记录</p></li><li><p>  4、再更新账户余额，但有条件限定：只有流水号等于之前查询出的流水号时才更新</p></li><li><p>  5、然后检查更新余额的返回值，如果更新成功就提交事务，否则回滚事务。</p></li></ul></li></ul></li></ul></li><li><p>  分布式事务——2PC、3PC、TCC、Saga 和本地消息表</p><p>  下面例子展示不同模型之间的事务交互<br>  ​分布式事务的“分布式”可以是多主机的系统的事务，也可以是在单机中的不同系统（模型）</p><ul><li><p>  实现1：2PC（二阶段提交）</p><p>  例如:强一致性&amp;并发低场景，订单表（订单系统，下单并绑定消费券id）和消费券表（促销系统，对消费券改为已使用）<br>  ​2PC<br>  引入了一个事务协调者的角色，来协调两个系统的数据更新操作保持一致，要么都更新成功，要么都更新失败</p><ul><li><p>  1、准备阶段：协调者叫各方做准备工作（除了事务提交的所有工作）</p></li><li><p>  2、提交阶段：收到各方”待命”通知后，统一发号令:<br>  “提交”</p></li><li><p>  异常处理:</p><ul><li><p>  在准备阶段，如果任何一步出现错误或者是超时，协调者就会给两个系统发送“回滚事务”请求</p></li><li><p>  如果已进入提交阶段，整个分布式事务只能成功，反复重试，直到提交成功。</p><p>  如果这个阶段发生宕机，包括两个数据库宕机或者订单服务、促销服务所在的节点宕机，还是有可能出现订单库完成了提交，但促销库因为宕机自动回滚，导致数据不一致的情况。</p></li></ul></li><li><p>  ps: 2PC<br>  这个协调服务最好和订单服务或者优惠券服务放在同一个进程里，进程更少故障点更少性能更好</p></li><li><p>  缺点：执行过程会阻塞服务端的线程和数据库的会话，协调者是一个单点，宕机会导致事务超时</p></li></ul></li><li><p>  实现2：本地消息表(可以存MQ/DB/File)</p><p>  例如:适用在没依赖其他资源(eg:下单不需要锁库存)<br>  实时性要求不高场景，订单表和购物车表</p><ul><li><p>  1、在执行这个数据库事务过程中，在本地记录一条消息。这个消息就是一个日志，内容就是“清空购物车”这个操作。我们可以让订单库的事务，来保证记录本地消息和订单库的一致性。完成后可以给客户端返回成功响应</p></li><li><p>  2、用一个异步的服务，读取刚刚记录的清空购物车的本地消息，调用购物车系统的服务清空购物车。购物车清空之后，把本地消息的状态更新成已完成就可以了。异步清空购物车这个过程中，如果操作失败了，可以通过重试来解决。</p></li></ul></li></ul></li></ul></li></ul></li><li><p>  高并发应对方法（并发高-&gt;分库）</p><ul><li><p>  Redis保护DB</p><p>  了解常见缓存策略</p><ul><li><p>  Read/Write Through</p></li><li><p>  Cache Aside （更好，写操作与Read/Write Through不同）</p><p>  写操作更新成功后删除cache(没有cache就直接返回)<br>  ​读操作读不到cache就去读数据库再更新cache</p></li></ul></li><li><p>  分库 读写分离 读多写少</p><p>  与用户关联不大的数据，可以用Redis挡，但是涉及到用户订单等关联大的数据呢？<br>  主节点读写兼顾 从节点只读做热备</p><ul><li><p>  主从同步问题</p><ul><li><p>  主库提交事务</p></li><li><p>  从库复制（mysql半同步复制）</p><p>  mysql5.7可以配置至少几个从节点复制后就返回相应<br>  ​也可以配置提交事务和复制的先后顺序<br>  ​默认是先等待复制，再提交事务（同步复制）AFTER_SYNC<br>  异步复制有可能丢数据：从节点在复制中主节点挂了</p></li><li><p>  多从库的SLB和高可用方案：HAProxy+KeepAlived</p></li></ul></li><li><p>  主从延迟问题</p><p>  主库数据更新后是否需要立刻查询？</p><ul><li><p>  需要</p><p>  把‘更新、查询’合并成一个事务，所以更新后的查询会被路由到主库</p></li><li><p>  不需要</p><p>  更新后过几秒返回–&gt;下单后等几秒 ​</p></li></ul></li><li><p>  实现：</p><ul><li><p>  纯手工方式</p></li><li><p>  组件方式（推荐）</p><p>  得看编程语言的是否有读写分离组件</p></li><li><p>  代理方式（主流）</p><p>  不方便修改应用的代码</p></li></ul></li></ul></li></ul></li><li><p>  量大数据应对方法（数据量大-&gt;分表）</p><ul><li><p>  “拆”——分出历史表</p><ul><li><p>  归档历史数据，分出历史订单表</p><p>  如何删除3个月前的订单？详看14</p></li></ul></li><li><p>  最后一招——用“分片”分表</p><p>  引出“分片”：通过某字段找到数据在哪个库哪个表<br>  eg:在订单号的后几位加入用户ID<br>  就可以根据用户查出订单在哪个库哪个表<br>  eg:店铺订单,可以复制一个订单DB，把店铺ID设为Sharding ID ​</p></li><li><p>  分片算法</p><ul><li><p>  时间范围分片</p><p>  易出现热点问题，适用于数据多并发低的系统</p></li><li><p>  订单表hash分片</p><p>  取ID与分片数的模</p></li><li><p>  一致性hash算法</p><p>  hash算法都是为了均匀分布数据</p></li><li><p>  查表法</p><p>  eg:数据可视化系统:商品名映射到某个表 ​</p></li></ul></li><li><p>  Redis Cluster 存储海量数据</p><p>  低成本中小集群</p></li></ul></li><li><p>  MySQL to Redis</p><ul><li><p>  Kafka/RocketMQ</p></li><li><p>  Binlog实时更新Redis(更通用)</p><p>  实时解析Binlog –&gt;开源项目：Canal</p></li><li><p>  如何降级或补偿应对数据出现不一致</p></li></ul></li><li><p>  跨数据系统实时同步</p><p>  详见笔记p19</p><ul><li><p>  MQ多分区存储binlog</p><p>  因果关系的binlog需要hash到同1分区</p></li><li><p>  对面系统的同步程序多线程消费MQ</p></li></ul></li><li><p>  海量数据存储方案</p><ul><li><p>  分布式存储系统：对象存储、HDFS</p></li><li><p>  点击流、监控日志数据</p><ul><li><p>  Kafka、HDFS</p><p>  kafka高吞吐 不无限存 查询能力较差 ​HDFS查询能力好 无限存储</p></li><li><p>  分布式流Pulsar/Bookkeeper、时序数据<br>  (监控数据)InfluxDB/OpenTsDB</p></li></ul></li><li><p>  海量数据提高查询速度</p><ul><li><p>  GB级 给分析系统单独配MySQL</p></li><li><p>  10GB HBase Cassandra ClickHouse 列式DB</p></li><li><p>  ES 成本高 内存占用大 但推荐</p></li><li><p>  TB级 定期聚合计算好存在HDFS<br>  再配合Map-Reduce、Spark、Hive做Data聚合计算</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;  CAP理论&lt;/p&gt;
&lt;p&gt;  不关注单节点系统，也不关注没有数据共享的多节点系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;  事务的ACID特性（AD必须要保证）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;  A 原子性 C 一致性 I 隔离性 D 持久性&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="后端知识" scheme="https://jiac3366.github.io/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL必知必会</title>
    <link href="https://jiac3366.github.io/2021/08/14/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>https://jiac3366.github.io/2021/08/14/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</id>
    <published>2021-08-14T09:41:44.577Z</published>
    <updated>2021-09-15T14:54:01.483Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>进阶</p><ul><li><p>B 树和 B+树区别</p><ul><li><p>数据存储位置</p><p>B 树的非叶子节点包含数据，而 B+树所有数据在叶子结点上</p></li><li><p>数据查询过程</p><p>B+树会不断递归地在非叶子节点（非叶子节点上有索引键和指向下一页的指针）上做二分查找，直到找到叶子结点，最后在叶子节点上做二分查找（详细请看“B+树检索[页]查询数据”）</p></li><li><p>B+树特性：B+树可以顺序地访问非叶子节点，做到数据的范围查询</p><p>1 个非叶子结点 key 指向的数据在它左右 2 边 key 所指向的数据的范围之内</p></li></ul></li><li><p>Hash 索引</p><ul><li><p>hash 索引不能用于 Order/group<br>by，不能支持最左前缀原则（多个 key 一起计算 hash），不支持模糊查询</p></li><li><p>适用 key-value 场景，当 mysql 某个条件查询频繁，就给这个条件字段生成自适应索引</p></li></ul></li><li><p>适用索引的场景</p><ul><li><p>Where 字段/value 唯一的字段/Distinct 字段/Join 连接字段</p></li><li><p>同时进行 Group A 和 Order<br>B 的查询时，应使用对应顺序的(A,B)联合索引</p></li></ul></li><li><p>不适用索引的场景</p><ul><li><p>数据太少</p></li><li><p>数据重复太多</p></li><li><p>数据更新频繁</p></li></ul></li><li><p>索引失效场景</p><ul><li><p>字段进行表达式/函数计算</p></li><li><p>WHERE 中使用 OR 的 2 个字段没有都建立索引</p></li><li><p>LIKE 直接跟%</p></li><li><p>索引列与 NULL 进行判断(所以要把字段设为非空)</p></li><li><p>(A,B)的联合索引用了 B 查询</p></li></ul></li><li><p>从数据页理解 B+树查询</p><ul><li><p>页&lt;区(连续)&lt;段&lt;表空间</p><ul><li><p>区：一个区有 64 个连续的页，默认页大小为 16k，所以一个区 1MB</p></li><li><p>段：区在操作系统中是连续分配的空间，即一个段</p><p>区在段中不一定是连续的，段也是数据库分配的单位，例如创建表段、索引段</p></li><li><p>表空间：一个 DB 由 1 个或多个表空间（逻辑容器）组成，一个表空间有 1 个或多个段，其中 InnoDB 共享（独立）表空间：多（一）张表用一个表空间</p></li></ul></li><li><p>InnoDB 页结构</p><p>不同 DBMS 页结构不同，通常一页有上千条记录</p><ul><li><p>(1) 文件头</p><ul><li><p>文件头 38B 带有上下文的指针</p></li><li><p>页头 56B 记录页的状态信息</p></li></ul></li><li><p>(2) 页记录</p><ul><li><p>最大最小记录 26B</p></li><li><p>用户记录</p></li><li><p>空闲记录</p></li></ul></li><li><p>(3)页目录（索引）</p><p>将(2)的记录分成若干分组，在页目录存对应数量的 slot，每个 slot 记录每个分组的结尾位置，充当索引的作用二分查找记录（空间换时间）</p></li><li><p>(4)文件尾 8B</p><p>其中的校验和会与文件头的校验值作对比</p></li></ul></li><li><p>B+树检索[页]查询数据过程</p><ul><li><p>(1)逐层检索 B+树直至找到叶子节点</p></li><li><p>(2)从页目录的槽查找数据所在的分组(二分查找)</p></li><li><p>(3)找到组后遍历单链表（记录之间是链表链接）</p></li></ul></li></ul></li><li><p>从磁盘 I/O 角度理解 SQL 查询的成本</p><ul><li><p>查看缓冲池的大小，当缓冲池大小&gt;1G 时，缓冲池的实例数才可以修改</p><p>[修改缓冲池大小：set global innodb_buffer_pool_size =<br>134217728]</p></li><li><p>数据页加载的 3 种方式</p><p>查询速度：缓冲池&gt;内存&gt;磁盘</p><ul><li><p>内存读取</p><p>（1 次读取 1 条记录 1ms）</p></li><li><p>随机读取</p><p>（在磁盘找页，10ms，6ms 等磁盘，3ms 排队，1ms 传输）</p></li><li><p>顺序读取（批量读取）</p><p>存储介质物理特性：顺序读&gt;多次随机读，设磁盘吞吐量 40MB/s，40M/16kB<br>= 0.4ms，每秒读约 2560 页 ​</p></li></ul></li><li><p>统计 SQL 查询成本，可以看到上一条 SQL 要读取页的数量</p><p>[SHOW STATUS LIKE ‘last_query_cost’]</p></li></ul></li><li><p>三星索引</p></li><li><p>关于锁</p><ul><li><p>共享锁和排他锁</p><ul><li><p>资源加上共享锁（S 锁）–&gt;只读，加上排他锁（X 锁）–&gt;均不可操作</p><p>当 INSERT/DELETE/UPDATE 时，数据库会对记录加 X 锁，当 SELECT 时，默认不加锁<br>​</p></li><li><p>意向共享/排他锁：当事务操作某些记录的数据，会在表上添加对应的意向锁，提示其他事务有人”占”了表中的某些记录</p></li><li><p>因为共享锁允许其他事务加共享锁(不排他)，多个读锁可能出现死锁</p><p>当第二个事务使用 UPDATE 等其他上排他锁的操作时，会不停地等待，超时</p></li></ul></li><li><p>乐观锁和悲观锁</p><p>是程序员对待数据并发风险的一种态度体现</p><ul><li><p>乐观锁（认为别人不会同时写入），使用版本机制或时间戳实现控制同一数据被“同时修改”</p></li><li><p>悲观，用数据量自身的锁机制</p></li></ul></li><li><p>死锁</p><p>因为在事务（进程）中，锁的获取是逐步的</p><ul><li><p>有锁的存在，死锁就有可能，eg:2 个事务都对资源获取共享锁，结果都没法更新操作</p></li><li><p>如何避免死锁</p><ul><li><p>若事务涉及多个表或一个表的大部分数据时，可以一次性锁定多个表或整个表</p></li><li><p>不同事务并发多张表，可以约定它们访问表的顺序(?</p></li></ul></li></ul></li></ul></li><li><p>事务隔离以及解决方案</p><ul><li>…</li></ul></li><li><p>MVCC 是解决什么问题的？</p><ul><li>…</li></ul></li><li><p>查询优化器如何工作</p><ul><li>…</li></ul></li><li><p>使用性能分析工具定位 SQL 执行慢的原因</p><ul><li>…</li></ul></li></ul><p>-</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进阶&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;B 树和 B+树区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据存储位置&lt;/p&gt;
&lt;p&gt;B 树的非叶子节点包含数据，而 B+树所有数据在叶子结点上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据查询过程&lt;/p&gt;
&lt;p&gt;B+树会不断递</summary>
      
    
    
    
    <category term="SQL" scheme="https://jiac3366.github.io/categories/SQL/"/>
    
    
  </entry>
  
</feed>

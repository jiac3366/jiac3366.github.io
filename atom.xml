<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://jiac3366.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiac3366.github.io/"/>
  <updated>2021-10-14T16:04:33.321Z</updated>
  <id>https://jiac3366.github.io/</id>
  
  <author>
    <name>Jiaccc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker容器知识汇总</title>
    <link href="https://jiac3366.github.io/2021/10/14/Docker%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://jiac3366.github.io/2021/10/14/Docker%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2021-10-14T15:51:55.571Z</published>
    <updated>2021-10-14T16:04:33.321Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>容器 = rootfs(静态视图) + Ns和Cgroups(动态视图)</p></li><li><p>Namespace</p><ul><li><p>docker创建容器进程时，实际是指定了这个进程所需要启用的一组 Namespace 参数，是一种特殊的进程</p><ul><li><p>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); </p></li><li><p>隔离的Namespace中的一些命令比如ping，netstat不受docker控制，容器是单进程意思是只有1个进程是可控的</p><ul><li><img src="https://api2.mubu.com/v3/document_image/f1e43398-5328-42e9-ab86-6fa103d40447-12600127.jpg" alt="img"></li></ul></li><li><p>缺点：共享宿主机内核，win容器应该不能在linux跑</p></li></ul></li></ul></li><li><p>Cgroup</p><ul><li><p>CPU/Memory</p><ul><li><p>watch ‘ps -aux|grep malloc|grep -v grep’  查看正在分配内存的应用，这个应用的二进制文件名叫malloc<img src="https://api2.mubu.com/v3/document_image/482838cc-cfaa-458c-abcb-08914e65edac-12600127.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/609a203b-3221-436e-bbef-3f4ff11e35ad-12600127.jpg" alt="img"></p></li><li><p>缺点：</p><ul><li>提及最多的自然是 /proc 文件系统，/proc 文件系统不了解 Cgroups 限制的存在<br>容器里执行 top 指令，显示的信息居然是宿主机的 CPU 和内存数据</li></ul></li><li><p>课后问题：如何修复容器中的 top 指令以及 /proc 文件系统中的信息</p><ul><li>A：top 是从 /prof/stats 目录下获取数据，所以道理上来讲，容器不挂载宿主机的该目录就可以了。lxcfs就是来实现这个功能的，做法是把宿主机的 /var/lib/lxcfs/proc/memoinfo 文件挂载到Docker容器的/proc/meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制.（改变容器top读取数据的位置）</li></ul></li></ul></li><li><p>Mount ns</p><ul><li><p>Mount ns跟其他 ns略有不同：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。<br>但我们希望的是：每当创建一个新容器时看到的文件系统就是一个独立的隔离环境，而不是默认继承自宿主机的文件系统。</p></li><li><p>Mount ns 对 chroot 的不断改良，做到默认挂载一个宿主机目录到容器根目录</p><ul><li>chroot $HOME/test /bin/bash<br>使用 $HOME/test 目录作为 /bin/bash进程(容器进程)的根目录</li></ul></li><li><p>目前，为了容器根目录更真实，一般挂载一个完整操作系统的文件系统（比如 Ubuntu16.04 的 ISO）——“容器镜像”，更专业就叫rootfs（根文件系统）。<br>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核，所以容器镜像不含内核，同一台机器上的所有容器，都共享宿主机操作系统的内核</p></li><li><p>Docker核心原理就是为待创建的用户进程：</p><ul><li><p>启用 Linux Namespace</p></li><li><p>设置指定的 Cgroups 参数</p></li><li><p>切换进程的根目录（Change Root）–优先用系统调用pivot_root ，没有就用chroot</p></li></ul></li><li><p>Union FS 联合文件系统</p><ul><li><p>AuFS: 镜像的层（5个）都放置在 /var/lib/docker/aufs/diff 目录下，然后被联合挂载（1个）在 /var/lib/docker/aufs/mnt 里面</p><ul><li><p>？？？？例子中的可读写层 ID  6e3be5d2ecccae7怎么来的<img src="https://api2.mubu.com/v3/document_image/96ea6bb5-b917-4a07-82fc-049808998484-12600127.jpg" alt="img"></p></li><li><p>5合1是如何做到的？信息记录在 /sys/fs/aufs</p><ul><li><p>通过cat /proc/mounts| grep aufs找到/var/lib/docker/aufs/mnt/id 这个id（例子中的6e3be5d2ecccae7）的挂载信息，得到si=972c6d361e6b32ba</p></li><li><p>再通过cat /sys/fs/aufs/si_972c6d361e6b32ba/br[0-9]*得到</p><ul><li>这就是宿主机存放这个镜像的层的真正文件<img src="https://api2.mubu.com/v3/document_image/b8018e6e-f2cd-4fbf-939e-634ce47204c0-12600127.jpg" alt="img"></li></ul></li></ul></li></ul></li><li><p>OverlayFS</p></li></ul></li><li><p>docker创新点：设计了增量rootfs，用到了Union FS</p><ul><li><p>rootfs由三部分组成</p><ul><li><p>读写层（容器层），是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，会被提交到hub被其他人使用</p></li><li><p>Init层（在2大层中间），专门用来存放 /etc/hosts、/etc/resolv.conf 等，不会提交，仅对当前容器有效</p></li><li><p>只读层（镜像层）</p></li></ul></li><li><p>删除只读层：要删除只读层里一个名叫 foo 的文件，实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了，即“ro+whiteout”的方式</p></li><li><p>修改只读层：找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件。即“copy on write”的方式</p></li></ul></li></ul></li></ul></li><li><p>Dockerfile</p><ul><li><p>问题：SHELL 和 VOLUME命令</p></li><li><p>CMD和ENTRYPOINTT</p><ul><li>Docker 会为你提供一个隐含的 ENTRYPOINT，即：/bin/sh -c.不指定 ENTRYPOINT 时，CMD 的内容就是 ENTRYPOINT 的参数，实际上运行在容器里的完整进程是：/bin/sh -c CMD</li></ul></li><li><p>每个原语执行后，都会生成一个对应的镜像层。即使原语本身并没有明显地修改文件的操作（比如，ENV 原语），它对应的层也会存在。只不过在外界看来，这个层是空的</p></li><li><p>docker commit 提交增量更新</p><ul><li><p>这里你对镜像roofs做的修改就是copt-on-write，init层避免了 Docker 对 /etc/hosts 等文件做的修改也一起提交.<img src="https://api2.mubu.com/v3/document_image/69f0490b-bee8-43a8-9c7e-395a746c0955-12600127.jpg" alt="img"></p></li><li><p>它发生在宿主机空间，由于 Mount ns的隔离作用，宿主机不知道有目录绑定到容器中，也就是说，宿主机认为容器中可读写层的 /test 目录（/var/lib/docker/aufs/mnt/[可读写层 ID]/test），始终是空的</p></li></ul></li><li><p>docker exec原理：</p><p>加入到一个某个进程已有的 Namespace 当中，达到“进入”这个进程所在容器的目的</p><ul><li><p>docker inspect [容器id] | grep -I pid</p></li><li><p>ls -l  /proc/容器进程id/ns ——查看这个容器真实的 Namespace 文件, 这样就可以依靠系统调用做有意义的事了</p><ul><li><p>系统调用：setns()，可以指定一个进程进入另一个进程的ns</p></li><li><p>docker提供了：-net参数  让你启动一个容器并“加入”到另一个容器的net ns； –net=host，不会启动net ns，就意味会和宿主机直接共享网络栈<br>docker run -it –net container:4ddf4638572d busybox ifconfig</p></li></ul></li></ul></li><li><p>docker volume原理：</p><p>就算开启了 Mount ns，在执行 chroot（或者 pivot_root）之前，容器进程一直可以看到宿主机上的整个文件系统</p><ul><li><p>指定方式</p><ul><li><p> docker run -v /test …  ——默认在宿主机上创建一个临时目录 /var/lib/docker/volumes/[VOLUME_ID]/_data，然后把它挂载到容器的 /test 目录上</p></li><li><p> docker run -v /home:/test …</p></li></ul></li><li><p>相关执行顺序：容器启动 –&gt; 5合1准备好容器的roofs –&gt; /home挂载到/var/lib/docker/aufs/mnt/[可读写层 ID]/test （此时mount ns已开启，挂载事件只在这个容器里可见，在宿主机上看不见容器内部的这个挂载点，保证了容器的隔离性不会被 Volume 打破）在复习一下？？？inode知识盲区？？？–&gt;chroot系统调用<img src="https://api2.mubu.com/v3/document_image/536cef6d-b347-41ef-aac6-37e957734240-12600127.jpg" alt="img"></p></li><li><p>找的顺序：启动–&gt;docker volume ls 第一个id –&gt;ls /var/lib/docker/volumes/id/_data/</p></li><li><p>08inode知识盲区<img src="https://api2.mubu.com/v3/document_image/c6d3b2af-fdeb-41e3-a9ca-84c30eaeeb72-12600127.jpg" alt="img"></p></li><li><p>容器声明的 Volume 的挂载点虽然出现在读写层，但容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容器 = rootfs(静态视图) + Ns和Cgroups(动态视图)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Namespace&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker创建容器进程时，实际是指定了这个进程所需要启用的一组 Namespace 参数，是一</summary>
      
    
    
    
    <category term="Docker容器" scheme="https://jiac3366.github.io/categories/Docker%E5%AE%B9%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>CPU上下文切换（下）</title>
    <link href="https://jiac3366.github.io/2021/10/13/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3%20CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://jiac3366.github.io/2021/10/13/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/3%20CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2021-10-13T12:07:57.248Z</published>
    <updated>2021-10-14T15:59:22.621Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>vmstat</strong>用来分析系统的内存使用情况,也常用来分析CPU 上下文切换和中断的次数<br><img src="C:\Users\46304\AppData\Roaming\Typora\typora-user-images\image-20211013203206540.png" alt="image-20211013203206540"></p><ul><li>cs（context switch）是每秒上下文切换的次数。 </li><li>in（interrupt）则是每秒中断的次数。 </li><li>r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。 若大于CPU数说明存在CPU竞争</li><li>b（Blocked）则是处于不可中断睡眠状态的进程数 </li><li>us(user) </li><li>sy 系统CPU使用率 </li></ul></li><li><p>进一步每个进程的详细情况 使用<strong>pidstat</strong><br>pidtstat -w 5 隔5s输出一组数据  单位: 次/秒<br>-w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标<br><strong>默认显示进程指标数据，加-t才输出线程指标</strong> ——pidstat -wt 1</p><ul><li>cswch，自愿上下文切换，eg: 资源不足</li><li>nvcswch非自愿上下文切换，eg:时间片耗尽</li></ul></li><li><p><strong>sysbench</strong> 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况<br>sysbench –threads=10 –max-time=300 threads run</p><p><img src="C:\Users\46304\AppData\Roaming\Typora\typora-user-images\image-20211013204314491.png" alt="image-20211013204314491"></p></li><li><p> pidstat 只是一个进程的性能分析工具，而中断发生在内核态，怎样才能知道中断发生的类型呢？</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;vmstat&lt;/strong&gt;用来分析系统的内存使用情况,也常用来分析CPU 上下文切换和中断的次数&lt;br&gt;&lt;img src=&quot;C:\Users\46304\AppData\Roaming\Typora\typora-user-images</summary>
      
    
    
    
    <category term="Linux性能优化" scheme="https://jiac3366.github.io/categories/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>CPU上下文切换（上）</title>
    <link href="https://jiac3366.github.io/2021/10/12/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2%20CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://jiac3366.github.io/2021/10/12/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/2%20CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2021-10-12T12:10:12.922Z</published>
    <updated>2021-10-14T15:59:05.382Z</updated>
    
    <content type="html"><![CDATA[<ul><li>操作系统管理的“任务”有哪些？<ul><li>进程和线程</li><li>硬件触发信号</li></ul></li><li>系统负载升高因素之一：上下文切换频繁，缩短进程真正运行的时间</li><li>开销排名：进程上线文切换&gt;同进程线程上线文切换&gt;中断上线文切换&gt;内核模式切换&gt;协程上线文切换&gt;用户态函数调用上下文切换</li><li>根据“任务”不同，上下文切换也就有不同的场景<ul><li>进程上下文切换<ul><li>进程既可以在用户空间运行，又可以在内核空间中运行。</li><li>和系统调用（特权模式切换）的区别：<ul><li>1、进程上下文切换，是指从一个进程切换到另一个进程运行，而系统调用过程中一直是同一个进程在运行。</li><li>2、切换的资源<ul><li>系统调用的过程发生了 2次CPU 上下文切换。每次切换<strong>CPU寄存器</strong>和<strong>内核状态</strong>（内核资源）。<br>第一次：CPU 寄存器先保存原来用户态的指令位置，为了执行内核态代码， 需要更新为内核态指令的新位置。最后跳转到内核态运行内核任务。第二次同理。</li><li>进程上下文切换不仅切换CPU寄存器和内核状态，还需要切换<strong>虚拟内存、用户栈、全局变量</strong>（用户资源），当虚拟内存刷新后，<strong>TLB</strong>（负责从虚拟地址转换到物理地址）也要刷新。</li></ul></li></ul></li><li>什么时候会切换进程上下文？调度算法学一波！！<ul><li>进程时间片耗尽</li><li>进程需要的内存（系统资源）不满足–&gt;被挂起</li><li>主动sleep –&gt;被挂起</li><li>更高优先级的来了–&gt;被挂起</li><li>硬件中断发生–&gt;被挂起</li></ul></li></ul></li><li>线程上下文切换<ul><li>线程上下文分2种<ul><li>前后的线程不属于同一个进程–&gt;等同进程切换</li><li>前后的线程属于同一个进程–&gt;只切换线程的栈、寄存器等不共享的资源</li></ul></li></ul></li><li>中断上下文切换<ul><li>中断上下文只包括内核态中断处理程序执行所必需的状态（<strong>只发生在内核态</strong>），包括 CPU 寄存器、 内核堆栈、硬件中断参数等，并不涉及到进程的用户态，所以即便硬件中断打断了进程的执行，也不用保存和恢复这个进程的虚拟内存、全局变量等用户态资源.</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;操作系统管理的“任务”有哪些？&lt;ul&gt;
&lt;li&gt;进程和线程&lt;/li&gt;
&lt;li&gt;硬件触发信号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统负载升高因素之一：上下文切换频繁，缩短进程真正运行的时间&lt;/li&gt;
&lt;li&gt;开销排名：进程上线文切换&amp;gt;同进程线程上线文</summary>
      
    
    
    
    <category term="Linux性能优化" scheme="https://jiac3366.github.io/categories/Linux%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>各种锁</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2021-10-04T04:27:43.200Z</published>
    <updated>2021-10-14T15:57:55.380Z</updated>
    
    <content type="html"><![CDATA[<ul><li>忙等待锁-自旋锁<ul><li>当获取不到锁时，线程就会⼀直 wile 循环，不做任何事情，所以就被称为「忙等待锁」，也被称 为⾃旋锁<br>这是最简单的⼀种锁，⼀直⾃旋，利⽤ CPU 周期（占用着CPU），直到锁可⽤。在单处理器上，需要抢占式的调度器（即 不断通过时钟中断⼀个线程，运⾏其他线程）。否则，⾃旋锁在单 CPU 上⽆法使⽤，因为⼀个⾃旋的线程 永远不会放弃 CPU。？</li></ul></li><li>无等待锁<ul><li>当没获取到锁的时候，就把当前线程放⼊到锁的等待队列，然后执⾏调度程序，把 CPU 让给其他线程执⾏</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;忙等待锁-自旋锁&lt;ul&gt;
&lt;li&gt;当获取不到锁时，线程就会⼀直 wile 循环，不做任何事情，所以就被称为「忙等待锁」，也被称 为⾃旋锁&lt;br&gt;这是最简单的⼀种锁，⼀直⾃旋，利⽤ CPU 周期（占用着CPU），直到锁可⽤。在单处理器上，需要抢占式的调度器（即 不</summary>
      
    
    
    
    <category term="操作系统" scheme="https://jiac3366.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP的缓存代理</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86/</id>
    <published>2021-10-04T03:11:25.120Z</published>
    <updated>2021-10-14T15:55:02.983Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP缓存功能主要由proxy server实现</p><ul><li><p><strong>client和proxy缓存控制的区别</strong><br>因为proxy server面对多client，所以origin server要对他作多点限制</p><ul><li>区别是客户端or代理的缓存<ul><li>若是客户端，用<code>cache-control: private</code>标识</li><li>若是代理，用<code>cache-control: public</code></li></ul></li><li>区别cache验证的字段<ul><li>代理使用<code>proxy_revalidate</code>而不是<code>must_revalidate</code>,要求代理的缓存过期后回源server验证，client不回源</li></ul></li><li>区别cache生存时间字段<ul><li>使用<code>s-maxage</code>限定缓存在代理上能存多久，client仍然使用<code>max-age</code></li></ul></li><li>代理专属属性：<code>no-transform</code>，不准对缓存的数据做任何手脚，甚至是优化</li><li>详细请看20/21的流程图</li></ul></li><li><p>客户端的缓存控制补充</p><ul><li><code>max-stale=3</code>: 废旧度要小于3天，至多max-age过期3天还能使用</li><li><code>min-fresh=4</code>: 新鲜度要大于4天，max-age前4天内都不使用</li><li><code>only-if-cached</code>: 只接受代理的缓存，不接受源</li></ul></li><li><p>代理如何知道改次请求是否与上次的请求匹配</p><ul><li>vary字段——“<code>vary</code>字段记录下一些字段，这些字段是响应这个请求结果的依据”，所以代理收到带vary会提取里面的请求头计算hash，存入缓存或与已有的缓存作匹配</li></ul></li><li><p>删除URI对应的缓存数据</p><ul><li>自定义请求方法“PURGE”发给代理（?）</li></ul></li><li><p>试着自己画出缓存的流程图</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HTTP缓存功能主要由proxy server实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;client和proxy缓存控制的区别&lt;/strong&gt;&lt;br&gt;因为proxy server面对多client，所以origin server要对他作多点限制&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP的代理服务</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</id>
    <published>2021-10-04T02:46:13.762Z</published>
    <updated>2021-10-14T15:54:58.812Z</updated>
    
    <content type="html"><![CDATA[<ul><li>代理头字段：Via（请求头/响应头都有）<ul><li>谁转发了报文，就在报文的Via字段接着加上自己的IP?</li></ul></li><li><code>X-Forwarded-For</code>和<code>X-Real-IP</code><br>若只有1层代理，2个字段一样<ul><li>X-Forwarded-For追加的是请求方的IP——“为谁而转发”，最左边的即为client的IP</li><li>X-Real-IP只记录client的IP</li></ul></li><li>X-Forwarded要修改HTTP内容，性能低下，且在HTTPS中不能实现</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;代理头字段：Via（请求头/响应头都有）&lt;ul&gt;
&lt;li&gt;谁转发了报文，就在报文的Via字段接着加上自己的IP?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;和&lt;code&gt;X-Real-IP&lt;/code&gt;&lt;b</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP的缓存控制</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6/</id>
    <published>2021-10-04T02:08:47.530Z</published>
    <updated>2021-10-14T16:01:52.542Z</updated>
    
    <content type="html"><![CDATA[<p>格式：Cache-Control: [field]=[value]</p><ul><li><p>响应端</p><ul><li>Cache-Control的max-age与Cookie的Max-Age<br>2者有点相似<ul><li>Cache-Control的max-age为生存时间，起点是报文的创建时刻（包含网络链路传输时间）</li><li>但Cookie的Max-Age以报文收到的时间作为起点</li></ul></li></ul></li><li><p>请求端</p><ul><li>浏览器也可以使用Cache-Control<ul><li>F5: <code>Cache-Control:max-age=0</code>，故client没用缓存</li><li>Ctrl+F5: <code>Cache-Control:no-store</code>( 通常与F5一样，要看server怎么理解 )</li></ul></li><li>浏览器的前进和后退——跳转重定向，client无带Cache-Control，只用最基本请求头，不再进行网络通信</li><li>如何提高client更新缓存的效率？<ul><li>（1）发2次请求：先发HEAD验证，若有改动，再GET</li><li>（2）使用If开头的条件请求字段（2合1）<br>最常用If-Modified-Since、If-None-Match，<ul><li>???</li></ul></li></ul></li></ul></li><li><p><strong>Cache-Control其他控制缓存的属性</strong>：</p><ul><li>no_store: 不许缓存</li><li>no_cache: 允许缓存——但使用缓存前先与server验证当前cache是否是最新的cache，然后干什么你懂的啦</li><li>must_revalidate：允许缓存——缓存不过期就允许使用，但过期后如果还想要用必须与server验证(2)</li></ul></li><li><p>优先级：Cache-Control &gt;Expires</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;格式：Cache-Control: [field]=[value]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;响应端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cache-Control的max-age与Cookie的Max-Age&lt;br&gt;2者有点相似&lt;ul&gt;
&lt;li&gt;Cache-Control的m</summary>
      
    
    
    
    <category term="SQL" scheme="https://jiac3366.github.io/categories/SQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Cookie</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/Cookie/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/Cookie/</id>
    <published>2021-10-04T01:37:19.327Z</published>
    <updated>2021-10-14T15:54:53.278Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Cookie有效期用Expires, Max-Age属性设置<br>server过于健忘，有时会设多条cookie，用“；”分隔</p></li><li><p><code>Expires</code>和<code>Max-Age</code></p><ul><li>Expires为截止日期，是个绝对时间，如果更改本机时间可能会造成失效.</li><li>Max-Age+报文收到的时间即等于失效时间，优先使用</li></ul></li><li><p><code>Domain</code>和<code>Path</code>组成Cookie作用域<br>让client发送Cookie给指定URI(?)</p><ul><li>Domain指定所属域</li><li>Path指定路径，一般用”/“，代表域名所有的路径都使用</li></ul></li><li><p><code>HttpOnly</code></p><ul><li>防止客户端使用非HTTP方式 (例如Js) 获取Cookie——预防XSS</li></ul></li><li><p><code>SameSite</code>:value（?）<br>可以防XSRF</p><ul><li>值为Strict：不能随跳转URI跨站发送</li><li>值为Lax：允许GET/HEAD等安全方法，但禁止POST跨站发送</li></ul></li><li><p><code>Secure</code></p><ul><li>仅能用HTTPS传输Cookie，但Cookie在Browser明文存在</li></ul></li><li><p>Cookie最大作用：身份识别-广告追踪</p><ul><li>google给你贴个Cookie，别的网站通过读取它的Cookie（第三方Cookie）对你推广告</li></ul></li><li><p>会话Cookie</p><ul><li>不设置<code>Expires</code>和<code>Max-Age</code>，浏览器一关就失效，过期时间显示为“session”或“N/A”</li><li>Cookie大小&lt;=4k，以数据库记录(sqlite)存放</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cookie有效期用Expires, Max-Age属性设置&lt;br&gt;server过于健忘，有时会设多条cookie，用“；”分隔&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Expires&lt;/code&gt;和&lt;code&gt;Max-Age&lt;/code&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>重定向和跳转</title>
    <link href="https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC/"/>
    <id>https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC/</id>
    <published>2021-10-04T01:18:14.240Z</published>
    <updated>2021-10-14T15:54:49.937Z</updated>
    
    <content type="html"><![CDATA[<p>响应报文中有字段：Location: [URI]</p><ul><li>301永久重定向：意味着原URI不再存在了，今后必须用新的URI，浏览器可能会更新书签等，爬虫也会更新</li><li>302临时重定向：浏览器和爬虫会认为临时不可用原URI，执行简单跳转</li><li>303.307.308类似，但有细节上的约束，慎用！</li><li><strong>重定向是server控制浏览器的手段</strong><ul><li>域名更换/网站维护等避免404出现</li><li>增加多个类似的域名入口再跳到主站点</li></ul></li><li>重定向场景<ul><li>301-涉及到重大改变的，对SEO也挺重要</li><li>302-涉及到临时维护跳转到通知页或服务降级（双十一促销）</li></ul></li><li>一个跳转会有2次“请求-应答”(?)</li><li>浏览器的前进和后退——跳转重定向（?）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;响应报文中有字段：Location: [URI]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;301永久重定向：意味着原URI不再存在了，今后必须用新的URI，浏览器可能会更新书签等，爬虫也会更新&lt;/li&gt;
&lt;li&gt;302临时重定向：浏览器和爬虫会认为临时不可用原URI，执行简单跳转&lt;/li</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP连接管理</title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/</id>
    <published>2021-10-03T05:07:24.334Z</published>
    <updated>2021-10-14T15:55:50.083Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>长连接<code>Connection:&quot;Keep-alive&quot;</code><br>长连接：第一次请求后的请求复用第1次请求打开的TCP连接</p><ul><li>1.1默认启用长连接,client发送<code>Connection:&quot;Keep-alive&quot;</code>表示使用长连接，但server不会管这么多只要支持就发这字段.</li><li>server一般不主动关闭连接，可以设置Nginx的策略关闭<ul><li><code>keepalive_timeout</code> 超时时间</li><li><code>keepalive_requests</code> 长连接可发的最大请求数</li></ul></li></ul></li><li><p>如何优化缓解HTTP1.1队头阻塞——“请求-应答模型导致”<br>类似上班打卡，只要有一个人打不上卡，后面都等着</p><ul><li>“并发连接”（买多几台打卡机）=&gt;client同时对1server发起多个长连接，一般一个client最多并发6~8个长连接</li><li>“域名分片”（前台放不下这么多打卡机，在每个楼层放吧），本质上也是数量解决，HTTP对一个域名并发有限制(?)，那就多开几个域名，绑定到同一个服务器</li></ul></li><li><p>PS：</p><ul><li>长连接最重要是区分多个报文的开始和结束，使用<code>Content-Length</code>正确标记报文结束。对于流式传输，必须用分块传输编码(<code>Transfer-Encoding:chunked</code>?)</li><li><code>Connection:Upgrade + 状态码101</code>表示协议升级表示从HTTP切换到WebSocket</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;长连接&lt;code&gt;Connection:&amp;quot;Keep-alive&amp;quot;&lt;/code&gt;&lt;br&gt;长连接：第一次请求后的请求复用第1次请求打开的TCP连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.1默认启用长连接,client发送&lt;code&gt;Connecti</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型与编码</title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81/</id>
    <published>2021-10-03T04:41:00.843Z</published>
    <updated>2021-10-14T16:00:44.048Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>数据类型与编码</p><p>HTTP告诉上层应用这是什么数据——数据类型、压缩格式</p><ul><li><p>MIME数据类型</p></li><li><p>压缩格式</p><ul><li><p>gzip(GUN zip压缩格式 最流行)</p><p>Nginx gzip on仅仅对文本数据有效</p></li><li><p>deflate(zlib压缩格式)</p></li><li><p>br(专门HTTP优化的压缩算法)</p></li></ul></li><li><p>相关字段（<strong>Accept-xxx代表想要对方要干的，Content-xxx代表自己是这么干的</strong>）</p><ul><li><p><code>Accept</code>(client告诉server可接受的MIME类型)</p></li><li><p><code>Content-Type</code>（server告诉client实际发了啥MIME）</p><p>eg: text/html; charset=utf-8</p></li><li><p><code>Accept-Encoding</code>（client支持的压缩格式）</p></li><li><p><code>Content-Encoding</code>（server实际用的压缩格式）</p><p>以上2个不发说明 client不支持压缩 server也没有压缩</p></li></ul></li></ul></li><li><p>语言类型与编码</p><p>浏览器能解析多种数据类型，但又如何让它显示成不同国家的自然语言呢？</p><ul><li><p>相关字段</p><ul><li><p><code>Accept-Language</code></p><p>type-subtype:en-GB, en-US, zh-CN</p></li><li><p>Content-Language(少用)</p></li><li><p>Accept-Charset(少用)</p></li><li><p>注意：没有Content-Charset</p><p>“Content-Charset”相关内容在<code>Content-Type</code>（server告诉client实际发了啥MIME）</p></li></ul></li></ul></li><li><p>内容协商优先级</p><ul><li><p>分号权重比逗号低</p><ul><li>  <img src="https://api2.mubu.com/v3/document_image/0386cf82-829e-41ae-b4dd-474bcfa3874b-12600127.jpg"></li></ul></li></ul></li><li><p>服务器响应的结果</p><ul><li>  使用<code>vary</code>字段记录响应这个请求结果的依据</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据类型与编码&lt;/p&gt;
&lt;p&gt;HTTP告诉上层应用这是什么数据——数据类型、压缩格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MIME数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;压缩格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;gzip(GUN zip压缩格式 最流行)&lt;</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/1%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/1%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-10-03T03:32:56.814Z</published>
    <updated>2021-10-04T03:32:22.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="透视HTTP协议"><a href="#透视HTTP协议" class="headerlink" title="透视HTTP协议"></a>透视HTTP协议</h2><ul><li>HTTP1.1缺点<ul><li>请求-应答模式，会造成同步阻塞    </li><li>以文本格式传输Header，效率下降</li></ul></li><li><a href="./%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81.md">数据类型与编码</a></li><li><a href="./HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6.md">HTTP传输大文件</a></li><li><a href="./HTTP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86.md">HTTP连接管理</a></li><li><a href="./%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC.md">重定向和跳转</a></li><li><a href="./Cookie.md">Cookie</a></li><li><a href="./HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E6%8E%A7%E5%88%B6.md">HTTP的缓存控制</a></li><li><a href="./HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1.md">HTTP的代理服务</a></li><li><a href="./HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86.md">HTTP的缓存代理</a></li><li>HTTPS</li><li>对称与非对称加密</li><li>数字签名与证书</li><li>…</li><li>HTTP2特性概览</li><li>HTTP3展望</li><li>Nginx、OpenResty</li><li>WAF</li><li>CDN</li><li>Websocket：沙盒里的TCP</li><li>HTTP性能优化</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;透视HTTP协议&quot;&gt;&lt;a href=&quot;#透视HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;透视HTTP协议&quot;&gt;&lt;/a&gt;透视HTTP协议&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HTTP1.1缺点&lt;ul&gt;
&lt;li&gt;请求-应答模式，会造成同步阻塞    &lt;/l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP传输大文件</title>
    <link href="https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    <id>https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-03T03:09:44.579Z</published>
    <updated>2021-10-14T15:54:56.237Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Transfer-Encoding与Content-Length互斥</p><p>在响应头部<code>Transfer-Encoding:chunked</code>表示</p></li><li><p>交互流程：</p><ul><li>Server用<code>Accept-Ranges:bytes</code>告知client支持范围请求（视频快进功能）<br>不支持干脆不发</li><li>client使用<code>Range:bytes=x-y</code> 告知要的范围<br>eg:一个100字节文件, client要前10字节：Range:bytes=0-10</li><li>server收到Range字段后先检查合法性：非法返416，合法返206，并在头字段加<code>Content-Range:byes=x-y</code></li><li>client也可以一次性请求多个范围，响应报文数据类型字段为<code>multipart/byteranges</code>表示响应报文体由多段字节序列组成<ul><li>多段序列报文的格式与分块传输有一点区别</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Transfer-Encoding与Content-Length互斥&lt;/p&gt;
&lt;p&gt;在响应头部&lt;code&gt;Transfer-Encoding:chunked&lt;/code&gt;表示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;交互流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Serv</summary>
      
    
    
    
    <category term="HTTP" scheme="https://jiac3366.github.io/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="https://jiac3366.github.io/2021/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <id>https://jiac3366.github.io/2021/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</id>
    <published>2021-09-15T14:56:09.563Z</published>
    <updated>2021-09-15T14:56:58.773Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>  进程间通信</p><ul><li><p>  管道</p><p>  通信⽅式效率低，不适合进程间频繁地交换数据，匿名管道跟随进程的生命周期<br>  在 shell ⾥⾯执⾏ A | B 命令的时候，A 进程和 B 进程都是 shell<br>  创建出来的⼦进程<br>  如果要进程双向通信，要创建2个管道（不然父进程fork子进程也把管道读写描述符复制了，2者对同一个管道写读造成混乱）<br>  ​进程写⼊读取的数据都经过内核</p><ul><li><p>  | 匿名管道 特殊文件 在内存</p></li><li><p>  mkfifo myPipe 创建命名管道<br>  ls在文件系统能看到文件类型是p(pipe)</p></li></ul></li><li><p>  消息队列</p><p>  相比管道，可以频繁交换数据<br>  ​消息队列跟随内核的生命周期，会有两个宏定义 MSGMAX 和 MSGMNB<br>  ，它们以字节为单位，分别定义了⼀条消息的最⼤⻓度和⼀个队列的最⼤⻓度</p><ul><li><p>  缺点：⼀是通信不及时，二不适合⽐较⼤数据的传输，三存在⽤户态与内核态之间的数据拷⻉开销</p></li></ul></li><li><p>  共享内存</p><p>  拿出⼀块虚拟地址空间来，映射到相同的物理内存中</p></li><li><p>  信号量(p191)</p><p>  防⽌多进程竞争共享资源造成的数据错乱的保护机制，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。</p><ul><li><p>  信号初始化为 1 ，是互斥信号量</p><p>  在任何时刻只有⼀个进程在访问</p></li><li><p>  信号初始化为 10，是同步信号量</p><p>  保证进程 A 应在进程 B 之前执⾏</p></li></ul></li><li><p>  信号</p><p>  进程间通信机制中唯⼀的异步通信机制</p><ul><li><p>  Ctrl+C 产⽣ SIGINT 信号，表示终⽌该进程</p></li><li><p>  Ctrl+Z 产⽣ SIGTSTP 信号，表示停⽌该进程，但还未结束</p></li></ul></li><li><p>  Socket</p><p>  Socket<br>  通信不仅可以跨⽹络与不同主机的进程间通信，还可以在同主机上进程间通信</p><ul><li><p>  UDP 是没有连接的，不需要调⽤ listen 和 connect，要bind</p></li><li><p>  socket类型:6种（协议族：本机/Ipv4/Ipv6，通信特性：字节流/数据报）</p><p>  本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像<br>  TCP 和 UDP 要绑定 IP<br>  地址和端⼝，⽽是绑定⼀个本地⽂件，这也就是它们之间的最⼤区别。</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;  进程间通信&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;  管道&lt;/p&gt;
&lt;p&gt;  通信⽅式效率低，不适合进程间频繁地交换数据，匿名管道跟随进程的生命周期&lt;br&gt;  在 shell ⾥⾯执⾏ A | B 命令的时候，A 进程和 B 进程都是 shell&lt;br&gt;  </summary>
      
    
    
    
    <category term="操作系统" scheme="https://jiac3366.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>后端存储知识</title>
    <link href="https://jiac3366.github.io/2021/08/14/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86/"/>
    <id>https://jiac3366.github.io/2021/08/14/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86/</id>
    <published>2021-08-14T10:09:16.833Z</published>
    <updated>2021-10-14T15:59:59.640Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>CAP理论</p><p>不关注单节点系统，也不关注没有数据共享的多节点系统</p><ul><li><p>一致性</p><ul><li>保证可用性AP</li></ul></li><li><p>可用性</p><ul><li>保证一致性</li></ul></li><li><p>分区容忍性（一定需要）</p></li></ul></li><li><p>事务的ACID特性（AD必须要保证）</p><ul><li><p>A 原子性 C 一致性 I 隔离性 D 持久性<br>C 有流水就有余额变化<br>I  没提交的事务对于其他事务不可见</p></li><li><p>实现：（不可能100%实现ACID）</p><ul><li><p>数据库事务——四个隔离级别</p><ul><li><p><img src="https://api2.mubu.com/v3/document_image/6fb862fc-6616-4f05-afd9-6cacca8bd2f0-12600127.jpg" alt="img"></p></li><li><p>区分RC(读提交)和RR(可重复读)——一个事务能否读到其他事务对数据已提交的更新</p><ul><li><p>能： RC、不能：RR（mysql默认）</p></li><li><p>幻读很少遇到也基本不会影响数据准确性<br>RR屏蔽掉了其他事务对真实数据的修改，自己无法查询，但实际上数据已存在或已经修改</p></li><li><p>兼顾【性能、并发、一致性】的交易方案：</p><ul><li><p>1、给账户余额表增加一个 log_id 属性，记录最后一笔交易的流水号</p></li><li><p>2、首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号</p></li><li><p>3、然后写入流水记录</p></li><li><p>4、再更新账户余额，但有条件限定：只有流水号等于之前查询出的流水号时才更新</p></li><li><p>5、然后检查更新余额的返回值，如果更新成功就提交事务，否则回滚事务。</p></li></ul></li></ul></li></ul></li><li><p>分布式事务——2PC、3PC、TCC、Saga 和本地消息表</p><p>下面例子展示不同模型之间的事务交互<br>​分布式事务的“分布式”可以是多主机的系统的事务，也可以是在单机中的不同系统（模型）</p><ul><li><p>实现1：2PC（二阶段提交）</p><p>例如:强一致性&amp;并发低场景，订单表（订单系统，下单并绑定消费券id）和消费券表（促销系统，对消费券改为已使用）<br>​2PC 引入了一个事务协调者的角色，来协调两个系统的数据更新操作保持一致，要么都更新成功，要么都更新失败</p><ul><li><p>1、准备阶段：协调者叫各方做准备工作（除了事务提交的所有工作）</p></li><li><p>2、提交阶段：收到各方”待命”通知后，统一发号令: “提交”</p></li><li><p>异常处理:</p><ul><li><p>在准备阶段，如果任何一步出现错误或者是超时，协调者就会给两个系统发送“回滚事务”请求</p></li><li><p>如果已进入提交阶段，整个分布式事务只能成功，反复重试，直到提交成功。<br>如果这个阶段发生宕机，包括两个数据库宕机或者订单服务、促销服务所在的节点宕机，还是有可能出现订单库完成了提交，但促销库因为宕机自动回滚，导致数据不一致的情况。</p></li></ul></li><li><p>ps: 2PC 这个协调服务最好和订单服务或者优惠券服务放在同一个进程里，进程更少故障点更少性能更好</p></li><li><p>缺点：执行过程会阻塞服务端的线程和数据库的会话，协调者是一个单点，宕机会导致事务超时</p></li></ul></li><li><p>实现2：本地消息表(可以存MQ/DB/File)  </p><p>例如:适用在没依赖其他资源(eg:下单不需要锁库存) 实时性要求不高场景，订单表和购物车表</p><ul><li><p>1、在执行这个数据库事务过程中，在本地记录一条消息。这个消息就是一个日志，内容就是“清空购物车”这个操作。我们可以让订单库的事务，来保证记录本地消息和订单库的一致性。完成后可以给客户端返回成功响应</p></li><li><p>2、用一个异步的服务，读取刚刚记录的清空购物车的本地消息，调用购物车系统的服务清空购物车。购物车清空之后，把本地消息的状态更新成已完成就可以了。异步清空购物车这个过程中，如果操作失败了，可以通过重试来解决。</p></li></ul></li></ul></li></ul></li></ul></li><li><p>高并发应对方法（并发高-&gt;分库）</p><ul><li><p>避免重复请求、解决ABA（幂等性问题：其任意多次执行所产生的影响均与一次执行的影响相同）</p><ul><li><p>重复请求：后端提供生成订单号（返回值就是新的，全局唯一的）的服务，订单号作为订单表的主键，前端每次提交就自动带上</p></li><li><p>ABA：加入版本号字段</p></li></ul></li><li><p>Redis保护DB</p><p>了解常见缓存策略</p><ul><li><p>Read/Write Through</p></li><li><p><img src="https://api2.mubu.com/v3/document_image/e21377f7-e36d-4ad6-b590-76e56fd68cbd-12600127.jpg" alt="img"></p></li><li><p>Cache Aside （更好，写操作与Read/Write Through不同）<img src="https://api2.mubu.com/v3/document_image/55427285-4ae8-402a-894d-9ef3ef4588c0-12600127.jpg" alt="img"></p></li></ul></li><li><p>分库 读写分离 读多写少</p><p>与用户关联不大的数据，可以用Redis挡，但是涉及到用户订单等关联大的数据呢？<br>主节点读写兼顾 从节点只读做热备</p><ul><li><p>主从同步问题</p><ul><li><p>主库提交事务</p></li><li><p>从库复制（mysql半同步复制）<br>mysql5.7可以配置至少几个从节点复制后就返回相应<br>​也可以配置提交事务和复制的先后顺序<br>​默认是先等待复制，再提交事务（同步复制）AFTER_SYNC<br>异步复制有可能丢数据：从节点在复制中主节点挂了</p></li><li><p>多从库的SLB和高可用方案：HAProxy+KeepAlived</p></li></ul></li><li><p>主从延迟问题</p><p>主库数据更新后是否需要立刻查询？<br>是：把更新后的查合并成一个微服务放在一个事务中(？)，强制更新后的查打在主库<br>否：更新后几秒后再返回</p><ul><li><p>需要<br>把‘更新、查询’合并成一个事务，所以更新后的查询会被路由到主库</p></li><li><p>不需要<br>更新后过几秒返回–&gt;下单后等几秒<br>​</p></li></ul></li><li><p>实现：</p><ul><li><p>纯手工方式</p></li><li><p>组件方式（推荐）<br>得看编程语言的是否有读写分离组件</p></li><li><p>代理方式（主流）<br>不方便修改应用的代码的情况下</p></li></ul></li></ul></li></ul></li><li><p>数据量大的应对方法（数据量大-&gt;分表）</p><ul><li><p>“拆”——分出历史表</p><ul><li>归档历史数据，分出历史订单表<br>如何删除3个月前的订单？详看14</li></ul></li><li><p>最后一招——用“分片”分表<br>“分片”：通过某字段找到数据在哪个库哪个表<br>eg:在订单号的后几位加入用户ID 就可以根据用户查出订单在哪个库哪个表<br>eg:店铺订单,可以复制一个订单DB，把店铺ID设为Sharding ID<br>​根据什么属性分片就要根据什么属性查，所以对查询会作很多限制</p></li><li><p>分片算法</p><ul><li><p>时间范围分片<br>易出现热点问题，适用于数据多并发低的系统</p></li><li><p>订单表hash分片<br>取ID与分片数的模</p></li><li><p>一致性hash算法<br>hash算法都是为了均匀分布数据</p></li><li><p>查表法<br>eg:数据可视化系统:商品名映射到某个表</p></li></ul></li><li><p>Redis Cluster 存储海量数据</p><p>低成本中小集群</p><ul><li><p>如何存？</p><ul><li><p>数据key与16384取模，余数为所在槽</p></li><li><p>通过节点的映射表找真正节点<br>在每个节点存一个槽与节点的映射关系</p></li></ul></li><li><p>如何保持高可用？</p><ul><li>对每个分片增加从节点，做主从复制<br>从节点一般是热备 也可以读写分离</li></ul></li></ul></li></ul></li><li><p>MySQL to Redis</p><ul><li><p>Kafka/RocketMQ</p></li><li><p>Binlog实时更新Redis(更通用)<br>实时解析Binlog –&gt;开源项目：Canal</p></li><li><p>如何降级或补偿应对数据出现不一致</p></li></ul></li><li><p>跨数据系统实时同步</p><p>详见笔记p19</p><ul><li><p>MQ多分区存储binlog<br>因果关系的binlog需要hash到同1分区</p></li><li><p>对面系统的同步程序多线程消费MQ</p></li></ul></li><li><p>海量数据存储方案</p><ul><li><p>分布式存储系统：对象存储、HDFS</p></li><li><p>点击流、监控日志数据</p><ul><li><p>Kafka、HDFS<br>kafka高吞吐 不无限存 查询能力较差<br>​HDFS查询能力好 无限存储</p></li><li><p>分布式流Pulsar/Bookkeeper、时序数据 (监控数据)InfluxDB/OpenTsDB</p></li></ul></li><li><p>海量数据提高查询速度</p><ul><li><p>GB级 给分析系统单独配MySQL</p></li><li><p>10GB HBase Cassandra ClickHouse 列式DB</p></li><li><p>ES 成本高 内存占用大 但推荐</p></li><li><p>TB级 定期聚合计算好存在HDFS 再配合Map-Reduce、Spark、Hive做Data聚合计算</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CAP理论&lt;/p&gt;
&lt;p&gt;不关注单节点系统，也不关注没有数据共享的多节点系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一致性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证可用性AP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可用性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证一致性&lt;/</summary>
      
    
    
    
    <category term="后端架构" scheme="https://jiac3366.github.io/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL必知必会</title>
    <link href="https://jiac3366.github.io/2021/08/14/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>https://jiac3366.github.io/2021/08/14/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</id>
    <published>2021-08-14T09:41:44.577Z</published>
    <updated>2021-10-14T15:53:42.273Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>入门</p><ul><li><p>SQL执行顺序</p><ul><li><p>FROM  <left_table></p></li><li><p>ON <join_condition><join_type></p></li><li><p>JOIN  <right_table> </p></li><li><p>WHERE  <where_condition></p></li><li><p>GROUP BY  <group_by_list></p></li><li><p>HAVING <having_condition></p></li><li><p>SELECT</p></li><li><p>DISTINCT <select_list></p></li></ul></li><li><p>聚合函数</p></li><li><p>ORDER BY <order_by_condition></p></li><li><p>LIMIT <limit_number></p></li></ul></li><li><p>左表大用 IN, 右表大用EXIST，下图结果相同：WHERE条件加和不加效果一致？<img src="https://api2.mubu.com/v3/document_image/3b0d27b4-fae8-4544-b180-62261309c782-12600127.jpg" alt="img"></p><ul><li><p>OLTP实时性会比较高 随时需要CRUD 适合行式存储,OLAP用于汇总和分析 列式存储易于压缩（相邻数据的数据类型都是一样）可以降低I/O</p></li><li><p>InnoDB COUNT(*)/(1) 统计行数时间复杂度为O(N)  MyISAM为O(1)– &gt;MyISAM 的一致性由表级锁维护 数据表有一个 meta 信息存储了row_count值,尽量在数据表上建立二级索引，系统会自动采用key_len小的二级索引进行扫描（因为为主键采用的索引是聚簇索引，包含的信息多，会慢）</p></li><li><p>排序的字段应该加索引</p></li><li></li></ul></li><li><p>进阶</p><ul><li><p>B树和B+树区别？</p><ul><li><p>数据存储位置<br>B树的非叶子节点包含数据，而B+树所有数据在叶子结点上</p></li><li><p>数据查询过程<br>B+树会不断递归地在非叶子节点（非叶子节点上有索引键和指向下一页的指针）上做二分查找，直到找到叶子结点，最后在叶子节点上做B+树检索[页]查询数据过程</p></li><li><p>B+树特性：B+树可以顺序地访问非叶子节点，做到数据的范围查询<br>1个非叶子结点key指向的数据在它左右2边key所指向的数据的范围之内</p></li></ul></li><li><p>Hash索引</p><ul><li><p>hash索引不能用于Order/group by，不能支持最左前缀原则（多个key一起计算hash），不支持模糊查询</p></li><li><p>适用key-value场景，当mysql某个条件查询频繁，就给这个条件字段生成自适应索引</p></li></ul></li><li><p>适用索引的场景</p><ul><li><p>Where字段/value唯一的字段/Distinct字段/Join连接字段</p></li><li><p>同时进行Group A和Order B的查询时，应使用对应顺序的(A,B)联合索引</p></li></ul></li><li><p>不适用索引的场景</p><ul><li><p>数据太少</p></li><li><p>数据重复太多</p></li><li><p>数据更新频繁</p></li></ul></li><li><p>索引失效场景</p><ul><li><p>字段进行表达式/函数计算</p></li><li><p>WHERE中使用OR的2个字段没有都建立索引</p></li><li><p>LIKE 直接跟%</p></li><li><p>索引列与NULL进行判断(所以要把字段设为非空)</p></li><li><p>(A,B)的联合索引用了B查询</p></li></ul></li><li><p>从数据页理解B+树查询</p><ul><li><p>页&lt;区(连续)&lt;段&lt;表空间</p><ul><li><p>区：一个区有64个连续的页，默认页大小为16k，所以一个区1MB</p></li><li><p>段：区在操作系统中是连续分配的空间，即一个段<br>区在段中不一定是连续的，段也是数据库分配的单位，例如创建表段、索引段</p></li><li><p>表空间：一个DB由1个或多个表空间（逻辑容器）组成，一个表空间有1个或多个段，其中InnoDB共享（独立）表空间：多（一）张表用一个表空间</p></li></ul></li><li><p>InnoDB页结构</p><p>不同DBMS页结构不同，通常一页有上千条记录</p><ul><li><p>(1) 文件头</p><ul><li><p>文件头 38B 带有上下文的指针</p></li><li><p>页头 56B 记录页的状态信息</p></li></ul></li><li><p>(2) 页记录</p><ul><li><p>最大最小记录 26B</p></li><li><p>用户记录</p></li><li><p>空闲记录</p></li></ul></li><li><p>(3)页目录（索引）<br>将(2)的记录分成若干分组，在页目录存对应数量的slot，每个slot记录每个分组的结尾位置，充当索引的作用二分查找记录（空间换时间）</p></li><li><p>(4)文件尾 8B<br>其中的校验和会与文件头的校验值作对比 </p></li></ul></li><li><p>B+树检索[页]查询数据过程</p><ul><li><p>(1)逐层检索B+树直至找到叶子节点</p></li><li><p>(2)从页目录的槽查找数据所在的分组(二分查找)</p></li><li><p>(3)找到组后遍历单链表（记录之间是链表链接）</p></li></ul></li></ul></li><li><p>从磁盘I/O角度理解SQL查询的成本</p><ul><li><p>查看缓冲池的大小，当缓冲池大小&gt;1G时，缓冲池的实例数才可以修改<br>[修改缓冲池大小：set global innodb_buffer_pool_size = 134217728]</p></li><li><p>数据页加载的3种方式</p><p>查询速度：缓冲池&gt;内存&gt;磁盘</p><ul><li><p>内存读取<br>（1次读取1条记录 1ms）</p></li><li><p>随机读取<br>（在磁盘找页，10ms，6ms等磁盘，3ms排队，1ms传输）</p></li><li><p>顺序读取（批量读取）<br>存储介质物理特性：顺序读&gt;多次随机读，设磁盘吞吐量40MB/s，40M/16kB = 0.4ms，每秒读约2560页<br>​</p></li></ul></li><li><p>统计SQL查询成本，可以看到上一条SQL要读取页的数量<br>[SHOW STATUS LIKE ‘last_query_cost’]</p></li></ul></li><li><p>三星索引</p><ul><li>…</li></ul></li><li><p>关于锁</p><ul><li><p>共享锁和排他锁</p><ul><li><p>资源加上共享锁（S锁）–&gt;只读，加上排他锁（X锁）–&gt;读写均不可操作<br>当SELECT时，默认不加锁（快照读）；当INSERT/DELETE/UPDATE时，数据库会对记录加X锁（当前读）</p></li><li><p>加/解锁方式</p><ul><li><p>表</p><ul><li><p>共享锁 LOCK TABLE product_comment READ;  / UNLOCK TABLE;</p></li><li><p>排他锁 LOCK TABLE product_comment WRITE; /UNLOCK TABLE; </p></li></ul></li><li><p>数据行</p><ul><li><p>共享锁 SELECT xx FROM table WHERE user_id = 912178 LOCK IN SHARE MODE</p></li><li><p>排他锁 SELECT xx FROM table WHERE user_id = 912178 FOR UPDATE</p></li></ul></li></ul></li><li><p>意向共享/排他锁：当事务操作某些记录的数据，会在表上添加对应的意向锁，提示其他事务有人”占”了表中的某些记录</p></li><li><p>因为共享锁允许其他事务加共享锁(共享锁不排他)，多个读锁可能出现死锁<br>当第二个事务使用UPDATE等操作加上排他锁的操作时，会不停地等待，超时</p></li></ul></li><li><p>乐观锁和悲观锁</p><p>是程序员对待数据并发风险的一种态度体现</p><ul><li><p><img src="https://api2.mubu.com/v3/document_image/a3c35cef-8fa3-4789-b0b2-96c0a7b96e17-12600127.jpg" alt="img"></p></li><li><p>乐观锁（认为别人不会同时写入），使用版本机制或时间戳实现控制同一数据被“同时修改”<br>版本机制：<a href="https://mubu.com/app/edit/home/GiiTc-M9u0">后端存储知识</a> 中的【区分 RR(可重复读)/RC(读提交)】小节的解决方案</p></li><li><p>悲观，用数据量自身的锁机制</p></li></ul></li><li><p>死锁</p><p>因为在事务（进程）中，锁的获取是逐步的</p><ul><li><p>有锁的存在，死锁就有可能，eg:2个事务都对资源获取共享锁，结果都没法更新操作</p></li><li><p>如何避免死锁</p><ul><li><p>若事务涉及多个表或一个表的大部分数据时，可以一次性锁定多个表或整个表</p></li><li><p>不同事务并发多张表，可以约定它们访问表的顺序(?</p></li></ul></li></ul></li></ul></li><li><p>事务隔离如何实现？</p><ul><li><p>MVCC可以解决什么问题的？</p><ul><li><p>优点：</p><ul><li><p>通过版本号解决数据是否显示，即使读不加锁也实现数据隔离</p></li><li><p>读写互不阻塞，并发提高</p></li><li><p>解决一致性读（快照读）问题，查数据时只能读到这个时间点前事务提交的结果</p></li></ul></li><li><p>快照读/当前读</p><ul><li><p>快照读：不加锁的select</p></li><li><p>当前读：加锁的select和增删改<br>就是对数据行的共享锁和排他锁</p></li></ul></li><li><p>MVCC = Undo log(mv) + ReadView(cc) </p><ul><li><p>Undo log<br>操作这个数据的事务ID 遍历行记录的回滚指针可以查历史快照<br>​</p></li><li><p>ReadView</p><ul><li><img src="https://api2.mubu.com/v3/document_image/188c2b71-dd06-445c-9e3a-3d96c4ebc4a5-12600127.jpg" alt="img"></li></ul></li></ul></li><li><p>RR与RC在读取ReadView中存在不同</p><ul><li><p>RC每次读都会获取一次ReadView</p></li><li><p>RR会复用第一次读的ReadView所以见不到后面事务提交的数据</p></li></ul></li><li><p>InnoDB如何解决幻读</p><ul><li><p>在RR情况下，InnoDB通过Next Key + MVCC解决</p></li><li><p>行锁种类</p><ul><li><p>记录锁（RC采用），锁记录</p></li><li><p>间隙锁，锁记录旁，索引与索引之间的空隙</p></li><li><p>Next Key，等于记录锁+间隙锁</p></li></ul></li></ul></li></ul></li><li><p>RR级别业务中解决幻读的方案</p><ul><li><p>单数据库事务：参考版本机制：<a href="https://mubu.com/app/edit/home/GiiTc-M9u0">后端存储知识</a> 中的【区分 RR(可重复读)/RC(读提交)】小节的解决方案</p></li><li><p>多数据库：引入流水功能，流水本身不要出现数据一致性问题，所以字段要包括双方的帐户字段</p><ul><li>王争设计模式给出的流水方案–保持数据一致性<img src="https://api2.mubu.com/v3/document_image/bd549ffc-bdd4-48da-be3a-b7b45e673df2-12600127.jpg" alt="img"></li></ul></li></ul></li></ul></li><li><p>查询优化器如何工作</p><ul><li><p>逻辑优化——查询重写属于代数级语法级的优化</p></li><li><p>物理查询优化——基于代价的估算模型从连接路径中选代价最小的路径</p><ul><li><p>CBO</p></li><li><p>RBO</p></li></ul></li></ul></li><li><p>使用性能分析工具定位SQL执行慢的原因</p><ul><li>…</li></ul></li><li><p>InnoDB总结</p><ul><li><p>三大特性：自适应hash、插入缓冲、二次写</p><ul><li>自适应hash将B+树索引中的热点数据页的地址存到hash表中,再存到缓冲池<br>缓冲池两大特性：优先对频次高的热数据加载、预读，区别于查询缓存将查询结果缓存下来，8.0已启用</li></ul></li><li><p>SQL执行过程(server层)</p><ul><li><p>0 连接器</p><ul><li><p>定期断开长连接，占用内存大的查询先断掉，需要再重连</p></li><li><p>5.7后可以初始化连接，无需重连</p></li></ul></li><li><p>1 分析器——词法语法分析+语义分析，生成语法分析树</p><ul><li>判断语句正确表列、是否存在</li></ul></li><li><p>2 优化器——逻辑优化+物理查询优化，生成查询计划。查询优化器如何工作</p></li><li><p>3 执行器——判断有否权限，有就打开表使用引擎提供的接口查询</p></li></ul></li><li><p>联合索引补充</p><ul><li>…</li></ul></li></ul></li><li><p>SQL范式设计——围绕非主属性/主属性是否对于候选键是直接依赖？</p><p> 码 = 候选键(唯一确定记录的键)= 所有主键——其包含的所有属性都叫主属性<br>2NF：消除了非主属性对于候选键的部分依赖。<br>3NF：消除了非主属性对于候选键的传递依赖。<br>BCNF：消除主属性对于候选键的部分与传递依赖。</p><ul><li><p>1NF：字段不可拆分，任何的 DBMS 都会满足第一范式</p></li><li><p>2NF：表中非主属性要和表的候选键有完全依赖关系<br>即两个对象不能掺和在一起，2NF 告诉我们一张表就是一个独立的对象</p></li><li><p>3NF：任何非主属性都不传递依赖于候选键——保证只能由候选键直接决定非主属性，非主属性不能决定非主属性<br>不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于候选键的情况。</p></li><li><p><img src="https://api2.mubu.com/v3/document_image/a950f590-f84c-49fa-81ce-55fe6540d674-12600127.jpg" alt="img"></p></li><li><p><img src="https://api2.mubu.com/v3/document_image/8730c247-d93f-4abc-b821-8c8f989111da-12600127.jpg" alt="img"></p></li><li><p>eg：现在有一张学生选课表，包含的属性有学号、姓名、课程名称、分数、系别和系主任</p><ul><li><p>学生和课程要分开 –&gt;不是同一个对象，违反2NF<br>分成Student(学号,姓名,系别)和Course(课程号，课程名称)<br>2个对象中间加个表关联: SC(学号,课程号,分数)</p></li><li><p>要分成Student(学号,姓名,系别)和Sdept(系别,系主任)，因为学生决定系别，系别又决定系主任–&gt;违反3NF<br>非主属性系主任会传递依赖于学号</p></li></ul></li><li><p>BCNF：在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。<br>第22章 </p></li><li><p>反范式设计：通过空间换时间，提升查询的效率</p><p>在数据量大情况下 直接在评论表中加入用户名字段 就不用查询2个表</p><ul><li><p>使用场景：冗余信息有价值或者能大幅度提高查询效率的时候，数据仓库在设计上更偏向采用反范式设计。<br>如订单中的收货人信息，包括姓名、电话和地址等需要保存记录，但用户可以轻易修改这些信息</p></li><li><p>缺点：1.让数据库的设计更加复杂。2.增加系统的维护成本。<br>比如用户每次更改昵称的时候，都需要执行存储过程来更新，如果昵称更改频繁，会非常消耗系统资源</p></li></ul></li><li><p>杂谈：候选键就像这一行数据的老大，它能唯一决定这行记录。当然，这条记录有可能有多个老大，候选键中不包含的属性就是小弟们，2NF规定，老大与小弟们的关系，要么1对多，要么多对1，否则就不符合2NF。</p></li><li><p><img src="https://api2.mubu.com/v3/document_image/8ac18d3d-ed5c-4f05-a90f-fd2b5e49c52c-12600127.jpg" alt="img"></p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;入门&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQL执行顺序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;FROM  &lt;left_table&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ON &lt;join_condition&gt;&lt;join_type&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;J</summary>
      
    
    
    
    <category term="SQL" scheme="https://jiac3366.github.io/categories/SQL/"/>
    
    
  </entry>
  
</feed>

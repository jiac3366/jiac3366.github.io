<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://jiac3366.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiac3366.github.io/"/>
  <updated>2021-12-19T16:32:26.220Z</updated>
  <id>https://jiac3366.github.io/</id>
  
  <author>
    <name>Jiaccc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库 | 数据库设计</title>
    <link href="https://jiac3366.github.io/2021/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>https://jiac3366.github.io/2021/12/20/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-12-19T16:31:48.151Z</published>
    <updated>2021-12-19T16:32:26.220Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>SQL范式设计——围绕非主属性/主属性是否对于候选键是直接依赖？</p><p> 码 = 候选键(唯一确定记录的键)= 所有主键——其包含的所有属性都叫主属性<br>2NF：消除了非主属性对于候选键的部分依赖。<br>3NF：消除了非主属性对于候选键的传递依赖。<br>BCNF：消除主属性对于候选键的部分与传递依赖。</p><ul><li><p>1NF：字段不可拆分，任何的 DBMS 都会满足第一范式</p></li><li><p>2NF：表中非主属性要和表的候选键有完全依赖关系<br>即两个对象不能掺和在一起，2NF 告诉我们一张表就是一个独立的对象</p></li><li><p>3NF：任何非主属性都不传递依赖于候选键——保证只能由候选键直接决定非主属性，非主属性不能决定非主属性<br>不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于候选键的情况。</p></li><li><p><img src="https://api2.mubu.com/v3/document_image/a950f590-f84c-49fa-81ce-55fe6540d674-12600127.jpg" alt="img"></p></li><li><p><img src="https://api2.mubu.com/v3/document_image/8730c247-d93f-4abc-b821-8c8f989111da-12600127.jpg" alt="img"></p></li><li><p>eg：现在有一张学生选课表，包含的属性有学号、姓名、课程名称、分数、系别和系主任</p><ul><li><p>学生和课程要分开 –&gt;不是同一个对象，违反2NF<br>分成Student(学号,姓名,系别)和Course(课程号，课程名称)<br>2个对象中间加个表关联: SC(学号,课程号,分数)</p></li><li><p>要分成Student(学号,姓名,系别)和Sdept(系别,系主任)，因为学生决定系别，系别又决定系主任–&gt;违反3NF<br>非主属性系主任会传递依赖于学号</p></li></ul></li><li><p>BCNF：在 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系。<br>第22章 </p></li><li><p>反范式设计：通过空间换时间，提升查询的效率</p><p>在数据量大情况下 直接在评论表中加入用户名字段 就不用查询2个表</p><ul><li><p>使用场景：冗余信息有价值或者能大幅度提高查询效率的时候，数据仓库在设计上更偏向采用反范式设计。<br>如订单中的收货人信息，包括姓名、电话和地址等需要保存记录，但用户可以轻易修改这些信息</p></li><li><p>缺点：1.让数据库的设计更加复杂。2.增加系统的维护成本。<br>比如用户每次更改昵称的时候，都需要执行存储过程来更新，如果昵称更改频繁，会非常消耗系统资源</p></li></ul></li><li><p>杂谈：候选键就像这一行数据的老大，它能唯一决定这行记录。当然，这条记录有可能有多个老大，候选键中不包含的属性就是小弟们，2NF规定，老大与小弟们的关系，要么1对多，要么多对1，否则就不符合2NF。</p></li><li><p><img src="https://api2.mubu.com/v3/document_image/8ac18d3d-ed5c-4f05-a90f-fd2b5e49c52c-12600127.jpg" alt="img"></p></li></ul></li><li><p>ER图设计</p><ul><li><p>超市的进货模块：先确定实体，再拓展属性</p><ul><li>供货商、门店和顾客强实体，仓库和员工弱实体(虽然都可以独立存在，但是弱实体依赖门店这个实体)<img src="https://api2.mubu.com/v3/document_image/21e50912-35ab-4008-b564-5f60637aa60f-12600127.jpg" alt="img"><br>独立存在的是实体，不可再分的是属性</li></ul></li><li><p>销售模块</p><ul><li>商品和门店不依赖于任何其他实体，所以是强实体；会员和收银款台都依赖于门店，所以是弱实体<img src="https://api2.mubu.com/v3/document_image/fcaf13df-cf6a-4563-8d4e-319ab94a2184-12600127.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/9b18874e-d57e-4588-ac3e-abc04e1d998e-12600127.jpg" alt="img"></li></ul></li><li><p>如何从ER图转换至数据表：</p><p>（上图P和Q表示多，只是为了与M、N区别）</p><ul><li><p>一个实体通常转换成一个数据表，弱实体中加入强实体的外键，强实体和弱实体就是One2many<br>eg: 仓库转换成仓库表（demo.stock）<br>–branchid INT NOT NULL<br>​– 设置外键约束，与门店表（demo.branch）关联-&gt; CONSTRAINT fk_stock_branch FOREIGN KEY (branchid) REFERENCES branch (branchid)-&gt; );</p></li><li><p>一个多对多的关系，通常也转换成一个数据表（一般就是一些流水表，得取决业务涉及到什么实体）<br>这个 ER 模型中的多对多的关系有 2 个，分别是销售关系和进货关系<br>eg：进货关系表关联到 4 个实体，分别是供货商、商品、仓库、员工，所以，表中必须要包括这 4 个实体转换成的表的主键，按照数据表设计的第三范式的要求和业务优先的原则，我们把这个进货单表拆分成 2 个表，分别是进货单头表和进货单明细表（odoo就是这么干的）</p></li><li><p>一个 1 对 1，或者 1 对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表<br>eg：在流水单头表中，分别把 cashierid、memberid 和 operatorid 定义成了外键</p></li></ul></li></ul></li><li><p>分库分表</p><p>需要设计阶段就完成，类中可以使用正则去计算访问的服务器、数据库和表名称？？？</p><ul><li><p>垂直分表——拆分商品表 常用字段表和不常用字段表</p></li><li><p>垂直分库</p><ul><li><p>按照模块功能分库</p><p>销售、库存、营运、会员</p><ul><li>优点：数据量和访问流量都减少，不同业务之间的数据交互减少，故障风险减小</li></ul></li></ul></li><li><p>水平分表</p><ul><li><p>拆分已处理和正在处理的数据（DML频繁的数据）<br>已经验收的表，增加“验收”相关的字段 例如验收人和验收日期,经过验收的表不经常修改，只负责查询</p></li><li><p>拆分时间太久远的数据到历史表</p></li><li><p>也可以根据业务评估拆分，确保单个表数据量适中<br>例如对id大于500小于1000的数据拆到其他表</p></li></ul></li><li><p>水平分库</p><ul><li>和水平分表类似，例如每500个数据（商户），在同一个服务器创建新的数据库；每5000个数据，放置在不同的数据库</li></ul></li><li><p>问题：<img src="https://api2.mubu.com/v3/document_image/0f5cec3c-fe64-4021-a068-7fcd4fd04690-12600127.jpg" alt="img"></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SQL范式设计——围绕非主属性/主属性是否对于候选键是直接依赖？&lt;/p&gt;
&lt;p&gt; 码 = 候选键(唯一确定记录的键)= 所有主键——其包含的所有属性都叫主属性&lt;br&gt;2NF：消除了非主属性对于候选键的部分依赖。&lt;br&gt;3NF：消除了非主属性对于候选键的传递</summary>
      
    
    
    
    <category term="数据库" scheme="https://jiac3366.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Python高级 | 多进程多线程</title>
    <link href="https://jiac3366.github.io/2021/12/20/Python%E9%AB%98%E7%BA%A7/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://jiac3366.github.io/2021/12/20/Python%E9%AB%98%E7%BA%A7/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-12-19T16:22:03.896Z</published>
    <updated>2021-12-19T16:29:52.707Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>多进程多线程</p><ul><li><p>threading</p><ul><li>run()触发你传入的函数</li></ul></li><li><p>协程</p><ul><li>当I/O 操作非常多、非常 heavy、需要建立的连接也比较多的时候，一般会创建挺多的线程，但线程池线程数一般有一个建议数值。但是协程对于这种场景可以创建很多的协程数量来应对，防止线程池不够用的场景。</li></ul></li><li><p>GIL</p><ul><li><p>为什么有 GIL？和 CPython 的实现有关</p><p>GIL，CPython  解释器 中1个技术术语</p><ul><li><p>1、防止使用多个线程被分配到多个CPU执行用一份代码(?造成内存管理的引用计数发生race condition<br>CPython 使用引用计数来管理内存，如果有两个 Python 线程同时引用了 a，就会造成引用计数的 race condition，引用计数可能最终只增加 1，这样就会造成内存被污染。因为第一个线程结束时，会把引用计数减少 1，这时可能达到条件释放内存，当第二个线程再试图访问 a 时，就找不到有效的内存了。</p></li><li><p>2、CPython 大量使用 C 语言库，但大部分 C 语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。</p></li></ul></li><li><p>GIL如何工作：</p><p><img src="C:\Users\46304\AppData\Roaming\Typora\typora-user-images\image-20211220002952677.png" alt="image-20211220002952677"></p><p>每一个线程在开始执行时，都会锁住 GIL，以阻止别的线程执行</p><ul><li><p>CPython 中有个check_interval机制 ，去轮询检查线程 GIL 的锁住情况，在一个“合理”的时间范围内释放 GIL<br>每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会</p></li><li><p>所以check_interval机制导致随时打断程序运行，有了 GIL也还要继续考虑线程安全</p></li></ul></li><li><p>总结：多线程也可以被调度到多个CPU上，只是由于python的GIL的存在，python的单线程和多线程同时都只能利用一颗cpu核心，对于纯cpu heavy任务场景，不涉及到io耗时环节，cpu都是充分利用的，多线程和单线程相比反倒是多了线程切换的成本，所以性能反而不如单线程。</p></li></ul></li><li><p>Python垃圾回收机制</p><ul><li><p>引用计数</p><ul><li>对象的引用计数（指针数）为 0 的时候，自然它也就成为了垃圾，需要被回收</li></ul></li><li><p>循环引用问题（有两个 list 互相引用，这里极有可能引起内存泄露）</p><ul><li><p>引用计数为0不是垃圾回收的充要条件</p><p>Python 使用标记清除（mark-sweep）算法和分代收集（generational）启用针对循环引用的自动垃圾回收</p><ul><li><p>标记清除（mark-sweep）算法</p><ul><li>相当于遍历全图，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。但图遍历性能消耗严重，mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类的对象，只有容器类对象才有可能产生循环引用</li></ul></li><li><p>分代收集（generational）算法‘’</p><ul><li>新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活</li></ul></li></ul></li></ul></li><li><p>objgraph调试内存泄漏，可视化引用关系</p><ul><li><p>show_refs()，它可以生成清晰的引用关系图</p></li><li><p>show_backrefs()  <a href="https://mg.pov.lt/objgraph/">Python Object Graphs — objgraph 3.5.0 documentation (pov.lt)</a></p></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多进程多线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;threading&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;run()触发你传入的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当I/O 操作非常多、非常 heavy、需要建立的连接也</summary>
      
    
    
    
    <category term="Python高级" scheme="https://jiac3366.github.io/categories/Python%E9%AB%98%E7%BA%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>Python高级 | Spider Info</title>
    <link href="https://jiac3366.github.io/2021/12/20/Python%E9%AB%98%E7%BA%A7/%E7%88%AC%E8%99%AB%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>https://jiac3366.github.io/2021/12/20/Python%E9%AB%98%E7%BA%A7/%E7%88%AC%E8%99%AB%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/</id>
    <published>2021-12-19T16:19:45.280Z</published>
    <updated>2021-12-19T16:23:28.765Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Cookie登录</p><ul><li><p>Cookie池</p><ul><li><a href="https://github.com/Python3WebSpider/CookiesPool">https://github.com/Python3WebSpider/CookiesPool</a></li></ul></li><li><p>获取方式：</p><ul><li><p>Request解密js</p><ul><li><p><a href="https://github.com/pig6/login_taobao">https://github.com/pig6/login_taobao</a></p></li><li><p><a href="https://github.com/CharlesPikachu/DecryptLogin">https://github.com/CharlesPikachu/DecryptLogin</a></p></li></ul></li><li><p>Selenium模拟</p><ul><li><p>隐藏头部</p><ul><li>未闻Code</li></ul></li><li><p>鼠标滑动</p><ul><li><a href="https://pyautogui.readthedocs.io/en/latest/">Welcome to PyAutoGUI’s documentation! — PyAutoGUI documentation</a></li></ul></li></ul></li></ul></li></ul></li><li><p>代理IP</p><ul><li><p>ASDL</p><ul><li><p><a href="https://github.com/Python3WebSpider/AdslProxy">https://github.com/Python3WebSpider/AdslProxy</a></p></li><li><p><a href="https://blog.csdn.net/u014094101/article/details/111192564?spm=1001.2014.3001.5501">https://blog.csdn.net/u014094101/article/details/111192564?spm=1001.2014.3001.5501</a></p></li></ul></li><li><p>代理池</p><ul><li><a href="https://github.com/Python3WebSpider/ProxyPool">https://github.com/Python3WebSpider/ProxyPool</a></li></ul></li></ul></li><li><p>验证码</p><ul><li><p>极验</p><ul><li><a href="https://github.com/Python3WebSpider/CrackGeetest">https://github.com/Python3WebSpider/CrackGeetest</a></li></ul></li><li><p>易盾</p><ul><li><a href="https://github.com/yujunjiex/behavior_captcha_cracker">https://github.com/yujunjiex/behavior_captcha_cracker</a></li></ul></li></ul></li><li><p>逆向</p><ul><li><a href="https://github.com/Germey/Review_Reverse">Germey/Review_Reverse: 2019年末总结下今年做过的逆向，整理代码，复习思路。 拼夕夕Web端anti_content参数逆向分析 WEB淘宝sign逆向分析； 努比亚Cookie生成逆向分析； 百度指数data加密逆向分析 今日头条WEB端_signature、as、cp参数逆向分析 知乎登录formdata加密逆向分析 KNN猫眼字体反爬 Boss直聘Cookie加密字段__zp_stoken__逆向分析 (github.com)</a></li></ul></li><li><p>More:</p><p><a href="https://github.com/Python3WebSpider/CookiesPool">Python3WebSpider</a>、<a href="https://github.com/Germey">https://github.com/Germey</a> 崔庆才<br><a href="https://github.com/asyncins">https://github.com/asyncins</a> 韦世东</p><ul><li><p><a href="https://github.com/Python3WebSpider/TaobaoProduct">https://github.com/Python3WebSpider/TaobaoProduct</a></p></li><li><p>未闻Code</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cookie登录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cookie池&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Python3WebSpider/CookiesPool&quot;&gt;https://github.com/Pytho</summary>
      
    
    
    
    <category term="Python高级" scheme="https://jiac3366.github.io/categories/Python%E9%AB%98%E7%BA%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang |  类型转换</title>
    <link href="https://jiac3366.github.io/2021/12/20/Golang/Go%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BD%93/"/>
    <id>https://jiac3366.github.io/2021/12/20/Golang/Go%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BD%93/</id>
    <published>2021-12-19T16:14:12.484Z</published>
    <updated>2021-12-19T16:16:49.354Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>“类型断言”表达式 value, ok := interface{}(container).([]string)   ——理解为python的isinstance()还有额外转换赋值功能</p><ul><li><p>interface{}(container)   把container变量的值转换为空接口值，因为类型断言表达式的语法形式是x.(T)。其中的x必须是接口类型的，例如：.([]string)   判断前者的类型是否为切片类型 []string，如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）</p></li><li><p>区分对比：类型转换表达式的语法形式是T(x)<br>x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}），还可以是一个表达式</p></li></ul></li><li><p>一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（数据类型），如：struct{}、interface{}、[]string{}、map[int]string{}，而类型字面量是用来表示数据类型本身的若干字符，如：interface、map[int]string、[]string</p></li><li><p>GO的一些陷阱：</p><ul><li><p>1、uint8和int16之间的转换??</p><ul><li>int16类型的值-255的补码是1111111100000001。如果我们把该值转换为int8类型的值，那么 Go 语言会把在较高位置（或者说最左边位置）上的 8 位二进制数直接截掉，从而得到00000001。所以var srcInt = int16(-255)dstInt := int8(srcInt) ——dstInt的值就是1</li></ul></li><li><p>2、当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉</p></li><li><p>3、字符’�’是 Unicode 标准中定义的 Replacement Character，专用于替换那些未知的、不被认可的以及无法展示的字符，由于-1肯定无法代表一个有效的 Unicode代码点， string(-1)所以得到的总会是”�”</p></li><li><p>别名类型和潜在类型</p><ul><li><p>type MyString = string，别名类型主要是为了代码重构而存在的，byte是uint8的别名类型，而rune是int32的别名类型，没有其他区别</p></li><li><p>type MyString2 string，MyString2是一个全新的类型，潜在类型相同的不同类型的值之间是可以进行类型转换的</p><p>string可以被称为MyString2的潜在类型，表示MyString2 在本质上是string</p><ul><li><p>MyString2类型的值与string类型的值可以使用T(x)表达式进行互转</p></li><li><p>但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string</p></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“类型断言”表达式 value, ok := interface{}(container).([]string)   ——理解为python的isinstance()还有额外转换赋值功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;interface{}(contai</summary>
      
    
    
    
    <category term="Golang" scheme="https://jiac3366.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang | Golang的包管理</title>
    <link href="https://jiac3366.github.io/2021/12/20/Golang/Golang%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://jiac3366.github.io/2021/12/20/Golang/Golang%E5%8C%85%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2021-12-19T16:09:36.179Z</published>
    <updated>2021-12-19T16:14:06.347Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>01 ** |  **GOPATH 有什么意义</p><ul><li><p>GOPATH 每个目录都代表 Go 语言的一个工作区（workspace）</p><p>Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行</p><ul><li><p>Go 语言源码的组织方式</p><ul><li>一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径</li></ul></li><li><p>了解源码安装后的结果</p><ul><li><p>安装后如果产生了可执行文件，就可能会放进该工作区的 bin 子目录</p></li><li><p>安装后如果产生了归档文件（执行go install 后的.a文件，程序编译后生成的静态库文件/静态链接文件），就会放进该工作区的 pkg子目录</p><ul><li>生成的归档文件放置它的目录是：代码包的导入路径的直接父级 + pkg的平台相关目录 +  代码包目录<img src="https://api2.mubu.com/v3/document_image/7825341d-1276-4cd2-8db6-e3d2dff5b536-12600127.jpg" alt="img"></li></ul></li></ul></li><li><p>理解构建和安装 Go 程序的过程 </p><p>build和install都会执行编译、打包等操作  go build 不能生成包文件, go install 可以生成包文件</p><ul><li><p>构建 go build  (主要意义在于测试)</p><ul><li><p>构建的是库源码文件，结果文件只会存在临时目录。</p></li><li><p>构建的是命令源码文件，结果文件会在源码文件所在目录</p></li></ul></li><li><p>安装 go install （库源码文件?命令源码文件?）</p><p>操作会先执行构建，然后还会进行链接操作，把结果文件搬运到指定目录</p><ul><li><p>安装的是库源码文件，结果文件会被搬运到它所在工作区的 pkg 目录下的某个子目录中</p></li><li><p>安装的是命令源码文件，结果文件会被搬运到它所在工作区的 bin 目录中，或者环境变量GOBIN指向的目录中</p></li></ul></li><li><p>go get 相关</p><p><a href="https://blog.csdn.net/benben_2015/article/details/91957109">(20条消息) go get命令_benben的博客-CSDN博客</a></p><ul><li><p>1、对代码包的远程导入路径进行自定义的方法是：在该代码包中的库源码文件的包声明语句的右边加入导入注释，<br>例如：package semaphore // import “<a href="http://golang.org/x/sync/semaphore">golang.org/x/sync/semaphore</a>“，</p></li><li><p>2、而加入导入注释之后，用以下命令即可下载并安装该代码包<br>go get <a href="http://golang.org/x/sync/semaphore">golang.org/x/sync/semaphore</a>，Go 语言官网 <a href="http://golang.org/">golang.org</a> 下的路径 /x/sync/semaphore 并不是存放semaphore包的真实地址。我们称之为代码包的自定义导入路径</p></li></ul></li></ul></li></ul></li></ul></li><li><p>02丨命令源码文件</p><ul><li><p>命令源码文件是程序的运行入口，只能有一个，如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件<br>通过构建或安装命令源码文件，生成的可执行文件就可以被视为“命令”，既然是命令，那么就应该具备接收参数的能力。</p></li><li><p>如果目录中有命令源码文件，那么其他种类的源码文件（同目录下的其他文件？）也应该声明属于main包</p></li><li><p>flag包</p><ul><li><p>在运行命令源码文件的时候传入参数，查看参数的使用说明<img src="https://api2.mubu.com/v3/document_image/e385d7f0-dbf6-44da-bda4-9c410e06be49-12600127.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/27729696-2f24-4e1c-af0c-3788c98e6c7e-12600127.jpg" alt="img"></p></li><li><p>自定义命令源码文件的参数使用说明</p><ul><li><p>场景：更灵活地定制命令参数容器，可以用 Go 编写命令，并可以让它们像众多操作系统命令那样被使用，甚至可以把它们嵌入到各种脚本中。</p></li><li><p>在调用flag包中的一些函数（比如StringVar、Parse等等）的时候，实际上是在调用flag.CommandLine变量的对应方法。</p></li><li><p>实践：自己创建一个私有的命令参数容器？</p></li></ul></li></ul></li></ul></li><li><p>03丨库源码文件</p><p>库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序可以被其他代码使用</p><ul><li><p>go build jiac_gateway/try03 –路径是相对于GOPATH的src的，同属于main包，1_lib里的函数不用大写也可以被1.go引用<img src="https://api2.mubu.com/v3/document_image/a7a85f5b-d82b-4b40-b19c-9e3cdafcf151-12600127.jpg" alt="img"></p></li><li><p>库源码文件 1_lib.go 所在目录的相对路径是jiac_gateway/try_03_split/lib，而它却声明自己属于library包，如何导入？</p><ul><li><p>下面是需要弄清楚的，但写法不提倡，我们应该让声明的包名与其父目录的名称一致<img src="https://api2.mubu.com/v3/document_image/c2efb917-c35b-4733-b05a-1e44bb52b8d8-12600127.jpg" alt="img"></p></li><li><p>1_lib.go首字母为大写的程序实体才可以被当前包外的代码引用</p></li><li><p>go除了包权限规则，还可以通过创建internal代码包让代码仅仅能被当前模块中的其他代码引用（模块级私有）</p></li><li><p>课后：</p><ul><li>如导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，怎样解决这种冲突，有几种方式？<ul><li>A：导入代码包的时候给它起一个别名就可以了，比如： import libflag “dep/lib/flag”。或者，以本地化的方式???导入代码包，如：import . “dep/lib/flag”（”dep/lib/flag”包中公开的程序实体，会被视为当前代码包中的程序实体，eg: 导入语句import . fmt，直接用Printf就可以）</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;01 ** |  **GOPATH 有什么意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GOPATH 每个目录都代表 Go 语言的一个工作区（workspace）&lt;/p&gt;
&lt;p&gt;Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是</summary>
      
    
    
    
    <category term="Golang" scheme="https://jiac3366.github.io/categories/Golang/"/>
    
    
  </entry>
  
  <entry>
    <title>后端架构 | 负载均衡策略有哪些？</title>
    <link href="https://jiac3366.github.io/2021/12/20/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/"/>
    <id>https://jiac3366.github.io/2021/12/20/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5/</id>
    <published>2021-12-19T16:03:33.043Z</published>
    <updated>2021-12-19T16:05:59.969Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>SLB</p><p><a href="https://www.cnblogs.com/kevingrace/p/6137881.html">linux负载均衡总结性说明（四层负载/七层负载） - 散尽浮华 - 博客园 (cnblogs.com)</a><a href="https://www.cnblogs.com/kevingrace/p/6137881.html">linux负载均衡总结性说明（四层负载/七层负载） - 散尽浮华 - 博客园 (cnblogs.com)</a></p><ul><li><p>HTTP 重定向负载均衡（较少用）<br>应用服务器不得不使用公网 IP，外部访问者可以直接连接到应用服务器，系统的安全性会降低</p></li><li><p> DNS 负载均衡</p></li></ul><p>  两次负载均衡，一次通过 DNS 负载均衡，用户请求访问数据中心负载均衡服务器集群的某台机器，然后这台负载均衡服务器再进行一次负载均衡，将用户请求分发到应用服务器集群的某台服务器上.</p><ul><li><p>不同的用户进行域名解析的时候，返回不同的 IP（数据中心负载均衡服务器的 IP ）<br>第一次解析后，域名对应的IP缓存在本机，性能比HTTP重定向好</p></li><li><p>默认是轮询算法</p></li><li><p>缺点是TTL</p><ul><li><p>维护性差：客户端在TTL周期内永远用那一个IP，到过期了才采用下一个IP，这期间服务端IP变了客户端无法得知</p></li><li><p>扩展性低：控制权在ISP</p></li><li><p>可用性差：解析时间长</p></li></ul></li><li><p>反向代理负载均衡（应用层（七层）负载均衡——Nginx/ Ingress/ Envoy是数据面  Istio是控制面）</p><ul><li><p>反向代理服务器是工作在 HTTP 协议层之上的，代理的也是 HTTP 的请求和响应，效率比较低<br>反向代理负载均衡通常用在小规模的互联网系统上，只有几台或者十几台服务器的规模。</p></li><li><p>GRPC LB是能做的，TCP转包是能做的，但如果是单客户端，有一个客户端流量很大，因为复用TCP的原因，如果有单个客户端发很大请求，其他客户端发很少的请求，大量的请求会到一个服务器去，不能保证均衡。一般需要应用层LB器支持。所以kube-proxy没办法满足这些保持连接的服务，一般通过nginx和envoy支持。还有一个问题，安全问题：service管不了应用层的东西，比如证书，所以ingress就是解决这些问题</p></li></ul></li><li><p>隧道技术——加一层包头(CNI是这么做的)</p><ul><li><p>VLAN 加UDP包头</p></li><li><p>IPinIP <img src="https://api2.mubu.com/v3/document_image/f4579cc0-876a-4d23-a0c5-e8f457c93823-12600127.jpg" alt="img"><br>LB封多一层包，服务器解包，然后从旁路回去</p></li></ul></li><li><p>TCP负载均衡</p><p>有应用跑在LB设备上，客户端与LB设备、LB设备与实际服务器都建立TCP连接</p><ul><li><p>如何把客户端IP往下带（虽然IP也会变化，但是用部分技术可以做到）</p><ul><li><p>TOC 协议 ，TCP包头有option位，可以把客户端IP支持，但要kernel都支持</p></li><li><p>proxy protocol，预留了TCP数据包第一个部分可以存客户端IP，需要上下游应用都支持（Nginx支持）</p></li></ul></li></ul></li><li><p>IP 负载均衡（ 网络层（三层）负载均衡, 有流量瓶颈）</p><ul><li><p>在操作系统内核直接修改 IP 数据包的地址，效率高</p></li><li><p>缺点是所有请求都要通过负载均衡服务器进行 IP 地址转换，况且响应的数据很大时会成为响应数据的流量瓶颈</p></li><li><p>NAT(不鼓励)</p><ul><li><p>修改目标 IP和源 IP(LB设备实际IP) ,客户访问的LB设备IP是虚拟IP，LB设备维护一个新目标IP(实际服务器)到客户端连接的记录表</p></li><li><p>缺点：客户端IP丢失</p></li></ul></li></ul></li><li><p> 数据链路层负载均衡 （应用服务器和负载均衡服务器都使用相同的虚拟 IP地址） ——DR模式到了pod 解得剩下里层包， 回包直接走DR模式通过默认网关回到client，回去直接路由</p></li></ul><p>  目前大型互联网应用基本都使用链路层负载均衡，虚拟 IP地址是什么原理？ 不常见</p><ul><li><p>负载均衡服务器并不修改数据包的 IP 地址，响应无需经过负载均衡服务器，解决响应数据量大,输出带宽不足的问题</p></li><li><p>负载均衡服务器的地位和路由器下的交换机类似，修改数据包的MAC地址，响应会直接到达用户的浏览器，而不会再经过负载均衡服务器<br>貌似决定负载均衡服务器交给哪台应用服务器去处理请求，是由用户的 mac 地址决定的</p></li><li><p>缺点：客户端和负载均衡服务器和应用服务器都要在同一个二层，外部客户端不支持</p></li><li><p>TIPS:</p><ul><li><p>Linux 上实现 IP 负载均衡和链路层负载均衡的技术是 LVS(ipvs)，目前 LVS 的功能已经集成到Linux 中了，通过 Linux 可以直接配置实现这两种负载均衡</p></li><li><p>负载均衡算法有轮询、随机、最少连接</p></li><li><p>写一个简化的 HTTP 重定向负载均衡 demo</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SLB&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kevingrace/p/6137881.html&quot;&gt;linux负载均衡总结性说明（四层负载/七层负载） - 散尽浮华 - 博客园 (cnblogs.com)&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="后端架构" scheme="https://jiac3366.github.io/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>后端架构 | 架构知识浅谈</title>
    <link href="https://jiac3366.github.io/2021/11/17/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/"/>
    <id>https://jiac3366.github.io/2021/11/17/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86/</id>
    <published>2021-11-17T00:01:56.868Z</published>
    <updated>2021-12-19T16:17:24.604Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Simple evolution</p><ul><li><p>第一次分离的时候，应用程序、数据库、文件系统分别部署在不同的服务器上</p></li><li><p>使用缓存改善性能，通过缓存读取数据。缓存主要有分布式缓存和本地缓存两种。分布式缓存将多台服务器共同构成一个集群，存储更多的缓存数据</p></li><li><p>因为连接大量的并发用户的访问，通过负载均衡服务器，将应用服务器部署为一个集群</p></li><li><p>数据库的读写分离</p></li><li><p>大多数的互联网应用而言，以上的分布式架构就已经可以满足用户的并发访问压力了</p></li><li><p>更上一层还需要解决：</p><ul><li><p>【海量数据的存储与查询】，主要通过分布式数据库、分布式文件系统、NoSQL 数据库解决</p></li><li><p>【网络带宽压力以及访问延迟】？部署独立的搜索引擎提供查询服务。同时减少数据中心的网络带宽压力，提供更好的用户访问延时、使用 CDN 和反向代理提供前置缓存</p></li><li><p>【实现系统的低耦合与模块化开发和部署】为了使各个子系统更灵活易于扩展，使用分布式消息队列将相关子系统解耦，通过消息的发布订阅完成子系统间的协作、使用微服务架构将逻辑上独立的模块在物理上也独立部署，单独维护，应用系统通过组合多个微服务完成自己的业务逻辑，实现模块更高级别的复用从而更快速地开发系统和维护系统</p></li></ul></li></ul></li><li><p>Cache</p><p>减少 CPU 的计算消耗，节省计算资源<br>​通读缓存（read-through）旁路缓存（cache-aside）区别在于缓存是否负责帮应用程序从数据源读取数据</p><ul><li><p>通读缓存（read-through）</p><p>如果没有，通读缓存就自己负责访问数据源，从数据源获取数据返回给应用程序，并将这个数据缓存在自己的缓存中，通常会作为系统架构的一部分，很多时候对应用程序是透明的</p><ul><li><p>CDN<br>静态内容和动态内容部署在不同的服务器集群上，使用不同的二级域名，即所谓的动静分离</p></li><li><p>反向代理缓存</p><ul><li>设计HTTP代理缓存</li></ul></li></ul></li><li><p>旁路缓存（cache-aside）</p><p>如果没有，就返回空（null）</p><ul><li><p>对象缓存</p><ul><li><p>本地缓存，使用和应用程序在同一个进程的堆空间存放缓存数据</p></li><li><p>分布式缓存</p><p>（每个程序需要依赖一个Memcached 的客户端 SDK）</p><ul><li>应用程序调用 API，API 调用 SDK 的路由算法，路由算法根据缓存的 key 值，计算这个key对应的内容的服务器 IP 地址和端口号，API 再调用 SDK 的通信模块，将 &lt;key, value&gt; 值以及缓存操作命令发送给具体的某台服务器</li></ul></li></ul></li></ul></li><li><p>解决数据脏读问题</p><ul><li><p>过期失效（使用更多）</p></li><li><p>失效通知</p></li><li><p>路由hash算法遇到增加服务器时候，会造成大量缓存不命中，可以用一致性哈希算法解决？？？</p></li></ul></li></ul></li><li><p>Asynchronous architecture（Event driven architecture）</p><ul><li><p>痛点：如何提高系统的写操作的性能呢？两个应用系统之间需要互相调用，其实把两个应用耦合起来了，被调用的应用产生了故障或者升级，都可能会引起调用者故障，或者也不得不升级！</p></li><li><p>消息队列的职责就是缓冲消息，等待消费者消费（在2个相互调用的服务之间增加一个队列）。根据消息消费方式又分为点对点模式和发布订阅模式两种。</p><ul><li><p>点对点模式（保证服务的）</p><ul><li><p>消费者程序可以部署在多台服务器上，但是对于任何一个消息，只会被发送给其中的一个消费者服务器。</p></li><li><p>这些服务器可以根据消息的数量动态伸缩，保证邮件能及时发送。</p></li><li><p>如果有某台消费者服务器宕机，既不会影响其他消费者处理消息发送邮件，也不会影响生产者程序正常运行</p></li></ul></li><li><p>发布订阅模式</p><ul><li><p>在消息队列中设置主题，多个消息消费者可以订阅同一个主题，每个消费者都可以收到这个主题的消息拷贝</p></li><li><p>与点对点区别：消息生产者不需要自行构造不同的业务消息到对应的mq中，只需要把普通数据加入到mq的某个主题，订阅该主题的不同消费者根据自己的业务消费该数据<br>eg 新用户注册的时候一方面需要发送激活邮件，另一方面可能还需要发送欢迎短信，还可能需要将用户信息同步给关联产品或数据库</p></li></ul></li></ul></li><li><p>该架构好处：</p><ul><li><p>改善写操作请求的响应时间</p></li><li><p>更容易进行伸缩</p><ul><li>负载均衡实现集群伸缩，但是这种集群伸缩是以整个应用服务器为单位的，但如果只是某些功能（例如图像处理）有压力，使用mq单独针对图片处理的消费者集群进行伸缩</li></ul></li><li><p>削峰填谷</p><ul><li>消费者可以控制消费速度，降低系统访问高峰时压力，在访问低谷时继续消费消息队列中未处理的消息，保持系统的资源利用率</li></ul></li><li><p>隔离失败</p><ul><li>消费者如果在处理消息的过程中失败，不会传递给生产者</li></ul></li><li><p>降低耦合</p><p>耦合会使软件僵硬、笨拙、难以维护</p><ul><li><p>代码的依赖</p></li><li><p>返回调用结果的依赖<br>如果调用出现异常，应用程序必须要处理这个异常</p></li></ul></li></ul></li></ul></li><li><p>Data storage architecture</p><ul><li><p>改善数据存储能力的主要手段包括：数据库主从复制、数据库分片、业务分库和NoSQL 数据库</p></li><li><p>主从复制（提高可用性，无法提升存储能力）</p><ul><li><p>一主多从<br>有的从数据库用来做实时数据分析，有的从数据库用来做批任务报表计算，有的单纯做数据备份</p></li><li><p>两主多从</p><p>两台服务器互相备份，仅仅用来提升数据写操作的可用性，并不能用来提高写操作的性能</p><ul><li>所有的应用程序都必须连接到同一个主数据库进行写操作，只有当该数据库宕机失效的时候，才会将写操作切换到另一台主数据库上。</li></ul></li></ul></li><li><p>业务分库（提高存储能力）</p><ul><li>将不同业务相关的数据库表，部署在不同的服务器上，每一类数据库还可以继续选择使用主从复制，或者主主复制</li></ul></li><li><p>数据库分片（提高存储能力）</p><ul><li><p>硬编码方式分片（根据数据ID映射成服务器编号），缺点是增加节点数，逻辑要修改</p></li><li><p>分布式关系数据库中间件分片（例如MYCAT）–类似查表法</p><ul><li>MYCAT 就可以解析出 SQL 中的地区字段 prov（根据地区进行数据分片），根据这个字段连接相对应的数据库</li></ul></li><li><p>余数 Hash 算法分片（更常见，分布均匀）</p><ul><li>根据主键 ID 和服务器的数目进行取模计算，根据余数连接相对应的服务器</li></ul></li><li><p>一致性hash算法</p></li></ul></li><li><p>NoSQL 数据库（Key、Value 的方式进行数据访问）</p><p>常用的 NoSQL 数据有 Apache HBase，Apache Cassandra、Redis， 与RDMS主要区别可用RDMS的ACID和NoSQL的BASE概括</p><ul><li> CAP 原理</li></ul><p>  一个提供数据服务的分布式系统无法同时满足数据一致性（Consistency）、可用性（Availability）和分区耐受性（Partition Tolerance）这三个条件。</p><ul><li><p>一个分布式系统而言，网络失效一定会发生，也就是说，分区耐受性（P）是必须要保证的，而对于互联网应用来说，可用性也是需要保证的，分布式存储系统通常需要在一致性上做一些妥协和增强</p></li><li><p>Apache Cassandra 解决数据一致性的方案是，在用户写入数据的时候，将一个数据写入集群中的三个服务器节点，等待至少两个节点响应写入成功。用户读取数据的时候，从三个节点尝试读取数据，至少等到两个节点返回数据，并根据返回数据的时间戳，选取最新版本的数据。这样，即使服务器中的数据不一致，但是最终用户还是能得到一个一致的数据，这种方案也被称为最终一致性。</p></li></ul></li></ul></li><li><p>Micro service</p><ul><li><p>单体架构缺点之一：一个巨型的应用必须把应用部署到大规模的服务器集群上。然后每个应用都需要与数据库建立连接，大量的应用服务器连接到数据库，会对数据库的连接产生巨大的压力，某些情况下甚至会耗尽数据库的连接</p></li><li><p>实施微服务最重要的是做好业务的模块化设计，如果业务关系没梳理好，模块设计不清晰，使用微服务架构很可能得不偿失，带来各种挫折</p></li><li><p>中台：-企业级能力复用平台</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Simple evolution&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一次分离的时候，应用程序、数据库、文件系统分别部署在不同的服务器上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用缓存改善性能，通过缓存读取数据。缓存主要有分布式缓存和本地缓存两种。分布式缓存将多</summary>
      
    
    
    
    <category term="后端架构" scheme="https://jiac3366.github.io/categories/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | 写入etcd的过程</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/etcd%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/etcd%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B/</id>
    <published>2021-11-16T23:57:43.379Z</published>
    <updated>2021-12-19T16:08:43.422Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>写入etcd的过程</p><ul><li><p>1、预检查</p><ul><li><p>配额</p></li><li><p>限速</p></li><li><p>鉴权</p></li><li><p>包大小检查</p></li></ul></li><li><p>2、 经过kvSever传到一致性模块（写请求发给了follower会被一致性模块转发给leader）</p><p>基于Raft paper</p><ul><li><p>把请求放入raftLog(Memory暂存)</p></li><li><p>然后同时做2个操作</p><ul><li><p>MsgProp发给其他follower</p></li><li><p>写一个WAL log(二进制的, 将y=9序列化),后台有异步操作落盘 </p></li></ul></li></ul></li><li><p>3、其他follower接收到请求也做写自己raftLog 和WAL，最后给leader返回一个MsgAppResp</p></li><li><p>4、kvSever统计MatchIndex 是否超过半数follower确认,<br>目前还是日志，没有写状态机</p></li><li><p>5、当超半数确认，raftLog中的状态从unstable –&gt;committed，写MVCC模块（状态机）</p><ul><li><p>写treeIndex  key-value形式</p><ul><li><p>key是对象的key, value是版本信息，main revision（eg 最后一次版本号是4）和sub revision（第0次操作）, 所以可以get 某个key对应的revision<img src="https://api2.mubu.com/v3/document_image/450081df-b08d-47c4-a3f2-ed78c711ecb4-12600127.jpg" alt="img"></p></li><li><p>Metadata的resourceVersion读的就是modified信息</p></li><li><p>generation历史变动：3版本创建 历史版本是3和4（有2版本）</p></li></ul></li><li><p>写BoltDB  key-value形式</p><ul><li><p>key是revision</p></li><li><p>value是这条记录的整个信息</p></li></ul></li><li><p>为什么要写WAL呢，直接写MVCC不行吗？</p><ul><li><p>放个地方临时持久化，因为需等待其他follower半数以上同意，又要防止内存断电</p></li><li><p>当等到半数以上同意了，这时如果etcd挂了，大家已经确认的数据就可以直接从WAL中恢复</p></li><li><p>所以WAL是写入状态机之前等待协商的过程保证数据安全用的</p></li></ul></li></ul></li><li><p>6、落盘后，raftLog中的状态从committed–&gt;applied</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;写入etcd的过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、预检查&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配额&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;限速&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;鉴权&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包大小检查&lt;/p&gt;
&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | 容器网络基础</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</id>
    <published>2021-11-16T23:51:18.931Z</published>
    <updated>2021-12-19T16:08:31.281Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>32丨浅谈容器网络</p><ul><li><p>每个容器（把每一个容器看做一台主机）都有“网络栈”，就包括了：网卡（Network Interface）、回环设备（LoopbackDevice）、路由表（Routing Table）和 iptables 规则。</p></li><li><p>如何把这些容器“连接”到 docker0 网桥上？——叫Veth Pair的虚拟设备</p><ul><li><p>特点：被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，被用作连接不同 Network Namespace 的“网线”</p></li><li><p>其2端可以分别在容器和宿主机输入ifconfig查看，宿主机的网卡名字叫作 veth9c02e56，容器网卡名字叫eth0。并且，通过 brctl show 的输出，你可以看到这张网卡被“插”在了 docker0 上</p></li></ul></li><li><p>容器A  ping  容器B是通的，原理：</p><p>把docker0看成交换机，容器的网卡就是docker0交换机的端口，被限制在 NetworkNamespace 里的容器进程，实际上是通过 Veth Pair 设备 + 宿主机网桥的方式，实现了跟同其他容器的数据交换.</p><ul><li><p>首先要查询容器A的路由表查询到容器B的IP的网段要转发的gateway（0.0.0.0），0.0.0.0意味着这是一条直连规则，凡是匹配到这条规则的 IP包，应该经过本机的 eth0 网卡，通过二层网络直接发往目的主机，前提是需要MAC地址</p></li><li><p>容器A通过 eth0 网卡发送ARP广播查找容器B的MAC，docker0负责转发到其他插在它上面的虚拟网卡<br>eth0 网卡，是一个 Veth Pair，它的一端在容器的Network Namespace 里，而另一端则位于宿主机上（Host Namespace），并且被“插”在了宿主机的 docker0 网桥上，从而eth0可以认为是docker0网桥的一个端口</p></li><li><p>容器B因为网卡也插在docker0，回复ARP请求，容器A有了目的 MAC 地址，其 eth0 网卡就可以将数据包发出去</p></li><li><p>docker0处理转发，查询CAM 表（MAC地址表），转发到容器B的端口</p></li><li><p>可以打开iptables的TRACE 验证上述流程<img src="https://api2.mubu.com/v3/document_image/ac5942af-1abd-43bf-916a-d2a864859b64-12600127.jpg" alt="img"><br><a href="https://en.wikipedia.org/wiki/Iptables">iptables - Wikipedia</a></p></li></ul></li><li><p>心得：当你遇到容器连不通“外网”的时候，应该先试试 docker0 网桥能不能ping 通，然后查看一下跟 docker0 和 Veth Pair 设备相关的 iptables 规则（容器里面也有路由表哦，用route命令查看）是不是有异常，往往就能够找到问题的答案了</p></li><li><p>容器的“跨主通信”</p><ul><li>这个粉红色的Overlay Network有点像接在交换机上的路由器？</li></ul></li><li><p>课后：如果要在生产环境中使用容器的 HostNetwork 模式，需要做哪些额外的准备工作呢?</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;32丨浅谈容器网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每个容器（把每一个容器看做一台主机）都有“网络栈”，就包括了：网卡（Network Interface）、回环设备（LoopbackDevice）、路由表（Routing Table）和 iptables</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | K8s跨主机通信原理</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E8%B7%A8%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</id>
    <published>2021-11-16T23:49:02.369Z</published>
    <updated>2021-12-19T16:08:46.292Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>“跨主通信”的原理</p><ul><li><p>Flannel 支持三种后端实现（本节介绍后2种）</p><p>Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。</p><ul><li><p>host-gw</p></li><li><p>UDP（flanneld 扮演者路由器的角色）</p><p>这个 UDP 包的源地址，就是flanneld 所在的 Node 1 的地址，目的地址是 container-2 所在的宿主机 Node 2 的地址<br>每台宿主机上的 flanneld，都监听着8285 端口</p><ul><li><p>1、出现跨宿主机通信，包会被交给默认路由规则，进入 docker0 与宿主机的路由进行匹配，进入到一个叫作 flannel0的设备，接着交给Flannel进程（内核态向用户态的流动）<br>在 Linux 中，TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备，只负责在操作系统内核和用户应用程序之间传递 IP 包。</p></li><li><p>2、flanneld 收到 IP 包的目的地址，就把它发送给了 Node 2宿主机， 它是如何知道这个 IP 地址对应的容器，是运行在 Node 2 上的？</p><ul><li><p>首先明白： Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网”，子网与宿主机的对应关系，保存在 Etcd<br>docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网</p></li><li><p>flanneld 处理flannel0 传入的 IP 包时，就可以根据目的 IP 的地址（比如100.96.2.3），匹配到对应的子网（比如 100.96.2.0/24），从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.168.0.3</p></li><li><p>若 Node 1 和 Node 2 是互通的，从Node1就可以发送给Node2</p></li></ul></li><li><p>缺点：</p><ul><li>相比于两台宿主机之间的直接通信，多了一个额外的步骤，即 flanneld 的处理过程：由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝<img src="https://api2.mubu.com/v3/document_image/e23ea751-34cb-43a5-8107-68a7729b4928-12600127.jpg" alt="img"></li></ul></li></ul></li><li><p>VXLAN</p><p>Virtual Extensible LAN（虚拟可扩展局域网）， Linux 内核本身就支持的一种网络虚似化技术，VXLAN 可以完全在内核态实现 UDP模式中在用户态进程flanneld:8285的封装和解封装的工作</p><ul><li><p>在现有的三层网络之上，“覆盖”一层虚拟的、由内核VXLAN 模块负责维护的二层网络<br>为在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道”的两端。<br>这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）作用和跟前面的 flanneld 进程十分类似<br>​差别在于封装和解封装的对象是二层数据帧；执行流程是在内核里完成的（因为 VXLAN 本身就是 Linux 内核中的一个模块）</p></li><li><p>Node 2 启动并加入 Flannel 网络之后， Node 1（以及所有其他节点）的flanneld 就会添加一条到 Node2 VTEP设备IP的路由规则<br>flannel.1 设备( VTEP 设备)替代了原flannel0 设备和主机eth0</p></li><li><p>VTEP 设备收到docker0发来的“原始 IP包”要想办法加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 VTEP 设备”，那么目的 VTEP 设备”的 MAC 地址是什么？因为Node1已有到Node2 VTEP的IP，所以自然要使用ARP，需要的 ARP 记录，也是 flanneld 进程在 Node 2 节点启动时自动添加在 Node 1上<br>（不依赖 L3 MISS 事件和 ARP 学习）可以通过 ip 命令查看——ip neigh show dev flannel.1<br>（ VTEP 设备和宿主机都有MAC地址哦）</p></li><li><p>加上“目的 VTEP 设备”的 MAC 地址，得到一个“内部数据帧”，但并不能在宿主机二层网络里传输<img src="https://api2.mubu.com/v3/document_image/0aa63b4a-3d17-492c-8a0a-3bb0ebb8be59-12600127.jpg" alt="img"></p></li><li><p>Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧，让它载着完整的二层数据帧，通过宿主机的 eth0 网卡进行传输，把这次要封装出来的、宿主机对应的数据帧称为“外部数据帧”（Linux 内核会把这个数据帧封装进一个 UDP 包里发出去）<br>Linux 内核会在“内部数据帧”前面，加上一个VXLAN 头表示“乘客”实际上是一个 VXLAN 要使用的数据帧，VXLAN 头里有个标志叫VNI，是 VTEP 设备识别某个数据帧是否归自己处理的重要标识。在 Flannel 中宿主机上的VTEP 设备都叫作 flannel.1 ，原因是这个“1”是VNI 标志的默认值</p></li><li><p>flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对方的宿主机地址的IP地址， UDP 包该发给哪台宿主机呢？</p><ul><li>flannel.1 设备实际扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而在 Linux 内核里面，“网桥”设备进行转发的依据，来自一个叫FDB（Forwarding Database）的转发数据库（相当于交换机的MAC表），bridge fdb 命令可以查看对方宿主机的IP<br> FDB 信息，也是 flanneld 进程负责维护的<br>bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37(对方 VTEP 设备的MAC，由ip neigh show dev flannel.1查出来的)</li></ul></li><li><p>Linux封包发送（Node 2 的 MAC 地址，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护）<img src="https://api2.mubu.com/v3/document_image/b73d8f15-bcc0-43b3-b356-4e43941ef15a-12600127.jpg" alt="img"></p></li><li><p>对方接受<img src="https://api2.mubu.com/v3/document_image/a77ec334-ab64-4c45-bdab-bd22825107e1-12600127.jpg" alt="img"></p></li></ul></li><li><p>后两种模式其实都可以称作“隧道”机制，也是很多其他容器网络插件的基础。比如 Weave 的两种模式，以及 Docker 的 Overlay 模式。</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“跨主通信”的原理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Flannel 支持三种后端实现（本节介绍后2种）&lt;/p&gt;
&lt;p&gt;Flannel 项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ho</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | K8s权限控制模型 RBAC</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%20RBAC/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/K8s%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B%20RBAC/</id>
    <published>2021-11-16T23:46:32.111Z</published>
    <updated>2021-12-19T16:08:48.655Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>很多实际的容器化工作，都会要求你设计一个自己的编排对象，实现自己的控制器模式。</p></li><li><p> K8s 里新增和操作 API 对象，必须先了解RBAC</p></li></ul><p>  负责完成授权（Authorization）工作的机制，就是 RBAC<br>  ​</p><ul><li><p>3大概念（Role + RoleBinding + ServiceAccount）</p><ul><li><p>Role</p><ul><li><p>产生作用的 Namepace 是：mynamespace<br>Namespace 并不会提供任何实际的隔离或者多租户能力</p></li><li><p>rules 字段，就是它所定义的权限规则<br>在上面的例子里：允许“被作用者”，对 mynamespace 下面的 Pod 对象，进行 GET、WATCH 和 LIST 操作<br>​</p></li></ul></li><li><p>RoleBinding</p><p>可以指定上面Role的“被作用者”</p><ul><li><p>“User”字段，只是一个授权系统里的逻辑概念</p><p>大多数私有的使用环境中，我们只要使用 Kubernetes 提供的内置“用户”，就足够</p><ul><li><p>可以通过外部认证服务，比如 Keystone来提供keystone?</p></li><li><p>也可以直接给 APIServer 指定一个用户名、密码文件</p></li></ul></li><li><p>roleRef字段</p><ul><li><p>绑定我们前面定义的 Role 对象（example-role）</p></li><li><p>Role对权限的限制规则仅在自己的 Namespace 内有效，roleRef 也只能引用当前 Namespace 里的 Role 对象</p></li></ul></li></ul></li><li><p>Subject(User)——一般用ServiceAccount，是由 k8s负责管理的“内置用户”</p><ul><li><p>ServiceAccount<br>apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  namespace: mynamespace<br>  name: example-sa</p></li><li><p>RoleBinding  下面的example-role在上面已经创建<img src="https://api2.mubu.com/v3/document_image/d040165b-09c4-44c8-9bc8-2aba91c9c133-12600127.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/0fe1e25b-2dcf-4eb1-b70f-105dbb24c901-12600127.jpg" alt="img"></p></li><li><p>实践：用Pod绑定按上述步骤创建的ServiceAccount</p><ul><li><p>Pod引用这个serviceAccount的name，创建成功后的Secret 对象（但cncamp课程演示 sa一旦被创建secrete就也一起被创建）（ServiceAccount 对应的用来跟 APIServer 进行交互的授权文件：Token）被mount到pod里面的/var/run/secret/<a href="http://k8s.io/sa()%E7%BC%A9%E5%86%99">k8s.io/sa(</a> ，pod应用带着它访问apiserver，apiserver就知道你是谁<img src="https://api2.mubu.com/v3/document_image/7e2fb66a-c287-426f-86ce-240760893cfc-12600127.jpg" alt="img"><br>Token 文件的内容一般是证书或者密码，以 Secret对象的方式保存在 Etcd </p></li><li><p>kubectl describe pod sa-token-test -n mynamespace   可以查看该 ServiceAccount 的 token<br>eg ：被 k8s自动挂载到了容器的/var/run/secrets/<a href="http://kubernetes.io/serviceaccount">kubernetes.io/serviceaccount</a>，容器里的应用就可以使用里面的 ca.crt 来访问 APIServer 了</p></li><li><p>tips:</p><ul><li><p>Pod 没有声明 serviceAccountName，Kubernetes 会自动在它的 Namespace 下创建一个名叫 default 的默认 ServiceAccount，然后分配给这个 Pod，有访问 APIServer 的绝大多数权限</p></li><li><p>你可以通过describe sa default查看对应的secret对象，也可以通过kubectl describe secret default-token-s8rbq查看对应的sa对象</p></li></ul></li></ul></li><li><p>用户组：一个 ServiceAccount，在 Kubernetes 里对应的“用户”的名字<br>system:serviceaccount:&lt;ServiceAccount 名字 &gt;</p></li><li><p>而它对应的内置“用户组”的名字<img src="https://api2.mubu.com/v3/document_image/128362d8-4094-47cb-b475-14b825527569-12600127.jpg" alt="img"><br>system:serviceaccounts:&lt;Namespace 名字 &gt;<br>name: system:serviceaccounts就意味着这个 Role 的权限规则，作用于整个系统里的所有 ServiceAccount</p></li></ul></li><li><p>更大的授权</p><p>：对于非 Namespaced（Non-namespaced）对象（比如：Node），或者某一个 Role 想要作用于所有的 Namespace 的时候，我们又该如何去做授权呢？</p><ul><li><p>ClusterRole和ClusterRoleBinding</p><p>用法跟 Role 和 RoleBinding 完全一样，只是没有了ns字段</p><ul><li><p>k8s内置了很多为系统保留的 ClusterRole</p><ul><li><p>eg ：system:kube-scheduler<br>绑定给 kube-system Namesapce下名叫 kube-scheduler 的 ServiceAccount（k8s调度器的 Pod 声明使用的 ServiceAccount）</p></li><li><p>1.cluster-admin；2. admin；3. edit；4. view<br>务必要谨慎而小心地使用 cluster-admin（cluster-admin是最高权限（verbs=*））</p></li></ul></li></ul></li><li><p>Role 或者 ClusterRole 里，如果要赋予用户 (是User，不是ServiceAccount )example-user 所有权限，那就可以给它指定一个 verbs 字段的全集<br> verbs: [“get”, “list”, “watch”, “create”, “update”, “patch”, “delete”]</p></li></ul></li><li><p>更细化的授权</p><ul><li>这条规则的“被作用者”，只对名叫“my-config”的 ConfigMap 对象，有进行 GET 操作的权限<img src="https://api2.mubu.com/v3/document_image/c24c7790-e127-4d0d-b7e1-6d81813ed574-12600127.jpg" alt="img"></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很多实际的容器化工作，都会要求你设计一个自己的编排对象，实现自己的控制器模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; K8s 里新增和操作 API 对象，必须先了解RBAC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  负责完成授权（Authorization）</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | API对象的奥秘！</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/API%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98%EF%BC%81/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/API%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%A5%E7%A7%98%EF%BC%81/</id>
    <published>2021-11-16T23:45:06.990Z</published>
    <updated>2021-12-19T16:08:37.751Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p> K8s是如何对 Resource、Group 和 Version 进行解析，从而找到 对象的定义呢</p></li><li><p>1、会匹配 API 对象的组<br>核心 API 对象，比如：Pod、Node 等， Group 是“”（不需要Group）会直接在 /api 这个层级进行下一步的匹配过程</p></li><li><p>2、匹配到 API 对象的版本号<br>同一种 API 对象可以有多个版本，这正是 Kubernetes 进行 API 版本化管理的重要手段。<br>比如在 CronJob 的开发过程中，对于会影响到用户的变更就可以通过升级新版本来处理，从而保证了向后兼容</p></li><li><p>3、Kubernetes 会匹配 API 对象的资源类型</p></li><li><p>APIserver交互流程</p><ul><li><p>1、授权、超时处理、审计</p></li><li><p>2、MUX 和 Routes 流程<br>APIServer 完成 URL 和 Handler 绑定的场所</p></li><li><p>3、APIServer 进行Convert 工作，把用户提交的 YAML 文件，转换成一个叫作 Super Version 的对象，它正是该 API 资源类型所有版本的字段全集。<br>这样用户提交的不同版本的 YAML 文件，就都可以用这个 Super Version 对象来进行处理</p></li><li><p>4、 Admission() 和 Validation() 操作</p><ul><li><p>上节提到的的 Admission Controller 和 Initialize</p></li><li><p>Validation，则验证这个对象里的各个字段是否合法<br>只要一个 API 对象的定义能在 Registry 里查到，它就是一个有效的 Kubernetes API 对象</p></li></ul></li><li><p>5、APIServer 会把验证过的 API 对象转换成用户最初提交的版本，进行序列化操作，并调用 Etcd 的 API 保存</p></li></ul></li><li><p>自定义CRD</p><ul><li><p>通俗说：为了让k8s认识这个对象</p><ul><li> register.go</li></ul><p>  pkg/apis/samplecrd/register.go</p><ul><li><p>放置后面要用到的全局变量</p></li><li><p>doc.go 起到的是全局的代码生成控制的作用  被称为 Global Tags<br>pkg/apis/samplecrd/doc.go,<br>+k8s:deepcopy-gen=package 意思是，请为整个 v1 包里的所有类型定义自动生成 DeepCopy 方法；<br>而+groupName=<a href="http://samplecrd.k8s.io/">samplecrd.k8s.io</a>，则定义了这个包对应的 API组的名字。</p></li><li><p> types.go </p></li></ul><p>  pkg/apis/samplecrd/types.go<br>  ​由于 Global Tags，不需要再显式地加上 +k8s:deepcopy-gen=true 了</p><ul><li><p>TypeMeta</p></li><li><p>ObjectMeta</p></li><li><p>Spec</p><ul><li><p>Cidr</p></li><li><p>Gateway</p></li></ul></li><li><p>register.go——addKnownTypes()</p><p>pkg/apis/samplecrd/v1/register.go</p><ul><li>让客户端也能“知道CRD, APIServer 会自动帮我们完成在服务器端的注册</li></ul></li><li><p>代码生成工具为资源类型生成clientset、informer 和 lister（详看PDF）<img src="https://api2.mubu.com/v3/document_image/439c380b-e645-4096-a36c-ce631e88e4f9-12600127.jpg" alt="img"></p></li><li><p>把其中的资源类型、GroupName 和 Version 替换成你自己的定义</p></li></ul></li><li><p>总结自定义对象工作分2部分：</p><ul><li><p>自定义资源类型的 API 描述<br>组Group、版本（Version）、资源类型（Resource）</p></li><li><p>自定义资源类型的对象描述<br>Spec、Status</p></li></ul></li></ul></li><li><p>tip:用 kubebuild 自动生成项目框架，添加自己的 CRD 并实现 controller 即可<img src="https://api2.mubu.com/v3/document_image/41bc3d9e-92b6-46f5-a9cb-a7996482f4eb-12600127.jpg" alt="img"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt; K8s是如何对 Resource、Group 和 Version 进行解析，从而找到 对象的定义呢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1、会匹配 API 对象的组&lt;br&gt;核心 API 对象，比如：Pod、Node 等， Group 是“”（不需要Grou</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | 声明式API与Kubernetes编程范式</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%E4%B8%8EKubernetes%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E5%A3%B0%E6%98%8E%E5%BC%8FAPI%E4%B8%8EKubernetes%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</id>
    <published>2021-11-16T23:41:27.313Z</published>
    <updated>2021-12-19T16:08:35.617Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>先 kubectl create，再 replace 的操作，称为命令式配置文件操作。</p></li><li><p>什么才是“声明式 API”——kubectl apply </p><p>创建和修改都用kubectl apply</p><ul><li><p>kubectl replace 是使用新的 YAML 文件中的API 对象，替换原有的 API 对象，一次只能处理一个写请求</p></li><li><p>kubectl apply是执行一个对原有 API 对象的PATCH 操作，一次能处理多个写操作，并且具备 Merge 能力</p></li></ul></li><li><p>Envoy——讲解一下声明式 API 在实际使用的重要意义</p><p>Envoy是一个高性能 C++ 网络代理，istio 的控制层（Control Plane）里的 Pilot 组件，能通过调用每个 Envoy容器的 API对Envoy 代理进行配置，实现微服务治理</p><ul><li><p>Envoy以 sidecar 容器的方式运行在每被治理的应用Pod 中，通过配置 Pod 里的 iptables 规则，接管整个 Pod 的进出流量</p></li><li><p>DynamicAdmission Control  ——“热插拔”式的 Admission 机制，也叫作：Initializer。</p><ul><li><p>背景： K8s 的1个 Pod 或者1个 API 对象被提交给 APIServer ，有一些“初始化”性质的工作需要在它们被正式处理之前进行<br>eg: 自动为所有 Pod 加上某些标签（Labels）</p></li><li><p>Istio 项目要做的，就是在1个 Pod YAML 被提交给 K8s 之后，在里面自动加上 Envoy 容器的配置</p><ul><li><p>Istio 会将 Envoy 容器本身的定义，以 ConfigMap 的方式保存，这个 ConfigMap 的 data 部分，正是一个 Pod 对象的一部分定义，所以会有重叠，所以更新用户的 Pod 对象的时候，必须使用 PATCH API 来完成<img src="https://api2.mubu.com/v3/document_image/2ed31cbd-2a90-4e4e-9ec5-b71a73b5259f-12600127.jpg" alt="img"></p></li><li><p>Istio 将一个编写好的 Initializer，作为一个 Pod 部署在 K8s 中，其中这个Initializer的工作过程如下：</p><p>这个 envoy-initializer 使用的 envoy-initializer:0.0.1 镜像，是一个事先写好的“自定义控制器”（Custom Controller），在下一篇文章中讲解</p><ul><li><p>initializer 控制器</p><ul><li><p>1、不断检查有无新pod创建,  实际就是死循环，逻辑伪代码<img src="https://api2.mubu.com/v3/document_image/aa117a1a-8f80-4afd-a19d-d06ea4fb79bc-12600127.jpg" alt="img"></p></li><li><p>2、从 APIServer 中拿ConfigMap的data</p></li><li><p>3、将 ConfigMap 里存储的 containers 和 volumes 字段，直接添加进一个空的Pod 对象里</p></li><li><p>4、使用k8sAPI，使用新旧两个 Pod 对象，生成一个 TwoWayMergePatch<img src="https://api2.mubu.com/v3/document_image/677b5a47-191c-44fb-a771-8ba04bd65547-12600127.jpg" alt="img"></p></li><li><p>5、调用 K8s 的 Client，发起一个 PATCH 请求</p></li><li><p>ps、指定要对什么样的资源起作用</p><ul><li>成功创建后，新创建的 Pod 的 Metadata 上就有这个Initializer的name，但initializer 里完成了要做的操作后，一定要记得将metadata.initializers.pending 标志清除掉<img src="https://api2.mubu.com/v3/document_image/2086faad-03cc-43a1-8017-f644bf38ecf8-12600127.jpg" alt="img"></li></ul></li><li><p>ps、在具体的 Pod 的 Annotation 里声明要使用哪个 Initializer,   eg：Annotation写<a href="http://initializer.kubernetes.io/envoy=true,">initializer.kubernetes.io/envoy=true,</a> 就会使用到我们前面所定义的envoy-initializer<img src="https://api2.mubu.com/v3/document_image/f1b02564-efe0-451d-bbaa-40b3de99b193-12600127.jpg" alt="img"></p></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>如何理解“Kubernetes 编程范式”，如何为 Kubernetes 添加自定义 API 对象，编写自定义控制器，正是这个晋级过程中的关键点</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;先 kubectl create，再 replace 的操作，称为命令式配置文件操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么才是“声明式 API”——kubectl apply &lt;/p&gt;
&lt;p&gt;创建和修改都用kubectl apply&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | StatefulSet是什么？</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/StatefulSet%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/StatefulSet%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2021-11-16T23:40:12.242Z</published>
    <updated>2021-12-19T16:08:54.943Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>18 深入理解StatefulSet（一）：拓扑状态</p><p>实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用” Stateful Application</p><ul><li><p>StatefulSet把真实世界的应用抽象成2种情况</p><p>在部署“有状态应用”的时候，应用的每个实例拥有唯一并且稳定的“网络标识”，是一个非常重要的假设</p><ul><li><p>拓扑状态</p></li><li><p>存储状态（下一节讲）</p></li></ul></li><li><p>Service被访问的方式有2种</p><ul><li><p>一、Service的虚拟 IP</p></li><li><p>二、Service的DNS</p><ul><li><p>访问这个dns，正是这个 Service 的 VIP，和（一）一致</p></li><li><p>访问这个dns直接解析出被代理 Pod 的 IP 地址，这就叫 Headless Service</p></li></ul></li></ul></li><li><p>小实践</p><ul><li><p>先创建 Headless Service</p><p>Headless Service 不需要分配一个 VIP，而是可以直接以 DNS 记录的方式解析出被代理 Pod 的 IP 地址<br>​仍是一个标准 Service 的 YAML 文件。只不过它的 clusterIP 字段的值是：None</p><ul><li>创建后，它所代理的所有 Pod（label selector选出来的） 的 IP 地址，都会被绑定一个DNS 记录</li></ul></li><li><p>再创建statefulset</p><p>只要知道了一个 Pod 的名字，以及它对应的 Service 的名字，就可通过这条 DNS 记录访问到 Pod 的 IP  </p><ul><li>和deployment YAML的唯一区别，就是多了一个 serviceName=nginx 字段，StatefulSet控制器会使用这个叫nginx 的Headless Service 来保证 Pod 的可解析身份（DNS记录）</li></ul></li><li><p>这时候创建一个pod  对statefulset维护的2个pod nslookup  和删除这2个pod后再nslookup  结果一致，说明Kubernetes 就成功地将 Pod 的拓扑状态（比如：哪个节点先启动，哪个节点后启动），按照 Pod 的“名字 + 编号”的方式固定了下来。<br>注意：解析到的Pod 的 IP 地址，并不是固定的，所以对于“有状态应用”实例的访问，你必须使用 DNS 记录或者 hostname 的方式</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;18 深入理解StatefulSet（一）：拓扑状态&lt;/p&gt;
&lt;p&gt;实例之间有不对等关系，以及实例对外部数据有依赖关系的应用，就被称为“有状态应用” Stateful Application&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;StatefulSet把真实世界</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | Depolymnet、ReplicaSet、Pod之间的关系</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/Depolymnet%E3%80%81ReplicaSet%E3%80%81Pod%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/Depolymnet%E3%80%81ReplicaSet%E3%80%81Pod%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2021-11-16T23:38:28.668Z</published>
    <updated>2021-12-19T16:08:40.799Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>只有容器能保证自己始终是 Running 状态的前提下，ReplicaSet 调整 Pod 的个数才有意义<br>也正是 Deployment 只允许容器的 restartPolicy=Always的原因</p></li><li><p>deployment状态字段</p><ul><li><p> kubectl scale deployment nginx-deployment –replicas=4  水平扩展</p></li><li><p>kubectl rollout status deployment/nginx-deployment<br>查看 nginx-deployment 的状态变化</p></li></ul></li><li><p>ReplicaSet 的 DESIRED、CURRENT 和 READY 字段的含义，和 Deployment 一致。<br>相比之下，Deployment 只是在 ReplicaSet 的基础上，添加了 UP-TO-DATE 这个跟版本有关的状态字段</p></li><li><p>使用 Pod 的 Health Check 机制检查应用的运行状态，当“滚动更新”停止，旧版本还能继续服务<br>容器 Running 状态时，但服务很有可能尚未启动，“滚动更新”的效果也就达不到了</p></li><li><p>Deployment、ReplicaSet 和 Pod 的关系.</p><ul><li><p>Deployment 的控制器控制的是 ReplicaSet 的数目（描述应用的版本），以及每个ReplicaSet 的属性（来保证 Pod 的副本数量）<br>：Deployment 控制 ReplicaSet（版本），ReplicaSet 控制 Pod（副本数）——deploy的yaml文件中同时定义replicaset和container，replicaset的replicas字段就是控制副本数的</p></li><li><p>1个应用的版本，对应的是1个 ReplicaSet，这个版本应用的 Pod 数量，则由ReplicaSet 通过它自己的控制器（ReplicaSet Controller）来保证</p><ul><li><p>对 Deployment 进行的每一次更新操作，都会生成一个新的 ReplicaSet 对象,会比较浪费资源</p><ul><li><p>1、kubectl rollout<br>在更新 Deployment 前，先执行 kubectl rollout pause deployment/nginx-deployment 让Deployment 处于“暂停”状态，这时对 Deployment 的所有修改，都不会触发新的“滚动更新”，也不会创建新的 ReplicaSet最后执行 kubectl rollout resume deploy/nginx-deployment 恢复回来</p></li><li><p>2、Deployment 对象字段， spec.revisionHistoryLimit<br>k8s为 Deployment 保留的“历史版本”个数，设置为 0，就再也不能做回滚操作了</p></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;只有容器能保证自己始终是 Running 状态的前提下，ReplicaSet 调整 Pod 的个数才有意义&lt;br&gt;也正是 Deployment 只允许容器的 restartPolicy=Always的原因&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;deployme</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | 控制器模型是怎样的？</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F/</id>
    <published>2021-11-16T23:36:56.605Z</published>
    <updated>2021-12-19T16:08:25.190Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>CRD 就是一个专门用来定义 Schema 的一个特殊的 API 对象</p></li><li><p>控制循环——“ReconcileLoop”（调谐循环）或者“Sync Loop”（同步循环）</p></li><li><p>被控制对象的定义，则来自于一个“模板”。</p><p>控制循环最后的执行结果，要么创建、更新一些Pod（或者其他的 API 对象、资源），要么删除一些已经存在的 Pod（或者其他的API 对象、资源）。</p><ul><li><p>Deployment 这样的一个控制器，上半部分是控制器定义（包括期望状态），下半部分的是被控制对象的模板</p></li><li><p>eg:  Deployment 里的 template 字段（PodTemplate（Pod 模板）），被这个 Deployment 管理的 Pod 实例，都是根据这个template 字段的内容创建的</p></li><li><p>问题：</p><ul><li><p>Kubernetes 使用的这个“控制器模式”，跟我们平常所说的“事件驱动”，有什么区别和联系吗？</p><ul><li><p>相当于select和epoll的区别</p></li><li><p>事件往往是一次性的，如果操作失败比较难处理，但是控制器是循环一直在尝试的，更符合kubernetes声明式API，最终达到与声明一致</p></li></ul></li><li><p>控制器主动获取pod状态，在这个集群中，有那么多pod，某个pod在某一时刻状态有变，怎样及时通知到控制器呢？informer机制</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CRD 就是一个专门用来定义 Schema 的一个特殊的 API 对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;控制循环——“ReconcileLoop”（调谐循环）或者“Sync Loop”（同步循环）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;被控制对象的定义，则来</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>K8s | 深入理解Pod对象</title>
    <link href="https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E5%AF%B9%E8%B1%A1/"/>
    <id>https://jiac3366.github.io/2021/11/17/Kubernetes/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Pod%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-11-16T23:33:26.186Z</published>
    <updated>2021-12-19T16:08:33.497Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>13 为什么需要Pod？</p><ul><li><p>背景：容器的“单进程模型”<br>容器没有管理多个进程的能力，因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程，用户进程没有管理其他进程的能力</p></li><li><p>解决：k8s把协同工作在同1个“进程组”的多个线程等价为1个Pod的多个容器，解决典型的成组调度（gang scheduling）问题，在Pod的层面进行资源分配（多个容器加起来需要的总资源作为一个原子调度单位）<br>具有“超亲密关系”容器的典型特征包括但不限于：互相之间会发生直接的文件交换、使用 <a href="http://localhost/">localhost</a> 或者 Socket 文件进行本地通信、会发生非常频繁的远程调用、需要共享某些 Linux Namespace（比如，一个容器要加入另一个容器的 Network Namespace）</p></li><li><p>重要：Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume|</p></li><li><p>A加入B的前提是B首先启动，所以为了保持Pod 里的多个容器就是对等关系：</p><ul><li>Pod 的实现需要使用一个中间容器，这个容器叫作 Infra 容器。在这个 Pod 中，Infra 容器永远都是第一个被创建的容器，用户定义的容器通过 Join Network Namespace 的方式，与 Infra 容器关联在一起，要为 Kubernetes 开发一个网络插件时只需要关注如何配置 Infra 容器的 Network Namespace 即可.</li></ul></li><li><p>用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器</p><ul><li><p>例子1：war包和tomcat分别做成2个镜像，war包是个 Init Container 类型的容器，它会按顺序逐一启动，等到他们启动并退后，spec.containers 定义的用户容器才启动，后面的tomcat（与war容器挂载了同一Volume）就看到Volume对应的宿主机目录中有war包</p><ul><li>上述例子是容器设计模式里最常用的一种模式：sidecar<br>sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。很多与 Pod 网络相关的配置和管理，也都可以交给 sidecar 完成，而完全无须干涉用户容器。最典型的例子莫过于 Istio 这个微服务治理项目</li></ul></li><li><p>例子2：一个最基本的日志收集工作：A往Volume中写日志，B也声明挂载同一个 Volume，然后B可以读取日志文件，转发到 MongoDB 或者 Elasticsearch 中存储起来。</p></li></ul></li><li><p>虚拟机和容器区别：</p><ul><li><p>部署方式：容器无法像虚拟机那样完全模拟本地物理机环境</p><ul><li><p>一个运行在虚拟机里的应用是被管理在 systemd 或者supervisord 之下的一组进程，而不是一个进程。<br>Swarm 这种单容器的工作方式，就难以描述真实世界这种复杂的应用架构，需要把一个运行在虚拟机里的应用迁移到 Docker 容器中时，要仔细分析到底有哪些进程（组件）运行在这个虚拟机</p></li><li><p>Pod实际上是在扮演“虚拟机”的角色；而容器只是一个进程，扮演这个虚拟机里运行的用户程序。</p></li></ul></li></ul></li></ul></li><li><p>14 深入理解Pod对象（一）（Pod对象字段）</p><ul><li><p>API对象到底哪些属性属于 Pod 对象，而又有哪些属性属于Container 呢？</p><p>——把 Pod 看成传统环境里的“机器”、把容器看作是运行在这个“机器”里的“用户程序”</p><ul><li><p>常用的Pod字段：(在第一个spec下)</p><p>凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的</p><ul><li><p>NodeSelector: a:b 这个 Pod 永远只能运行在携带了“a: b”标签（Label）的节点</p></li><li><p>HostAliases: 定义了 Pod 的 hosts 文件（比如 /etc/hosts），设置 hosts 文件一定要通过这种方法</p></li><li><p>shareProcessNamespace: true </p><ul><li>Pod 里的容器共享 PID Namespace<br>整个 Pod 里的每个容器的进程，对于所有容器来说都是可见的<br>​k attach -it nginx -c shell？？为啥无法交互了</li></ul></li><li><p>Pod共享宿主机的 Network、IPC 和 PID Namespace</p><ul><li><p>hostNetwork: true</p></li><li><p>hostIPC: true </p></li><li><p>hostPID: true</p></li></ul></li><li><p>container字段  –在deployment对象的第二个spec下，以下字段是container字段的属性</p><ul><li><p>Image（镜像）</p></li><li><p>Command（启动命令）</p></li><li><p>workingDir（容器的工作目录）</p></li><li><p>Ports（容器要开的端口）</p></li><li><p>volumeMounts（容器要挂载的 Volume）</p></li><li><p>imagePullPolicy </p><ul><li><p>默认值是 Always，即每次创建 Pod 都重新拉取一次镜像</p></li><li><p>Never ：Pod 永远不会主动拉取这个镜像</p></li><li><p>IfNotPresent：只有宿主机上不存在这个镜像时才拉取</p></li></ul></li><li><p>Lifecycle</p><ul><li><p>postStart指在容器启动后，立刻执行一个指定的操作<br>并不严格保证顺序，在 postStart 启动时，ENTRYPOINT 有可能还没有结束</p></li><li><p>preStop发生的时机是容器被杀死之前（比如，收到了 SIGKILL 信号）<br>会阻塞当前的容器杀死流程，直到这个 Hook 定义操作完成之后，才允许容器被杀死，和postStart不一样</p></li></ul></li></ul></li><li><p>Status</p><ul><li><p>pod.status.phase，是 Pod 的当前状态</p><ul><li><p>Pending 已提交给etcd,因为某种原因而不能被顺利创建, 比如调度不成功。</p></li><li><p>Running Pod 已经调度成功，跟一个具体的节点绑定。它包含的容器都已经创建成功，并且至少有一个正在运行中</p></li><li><p>Succeeded Pod 里的所有容器都正常运行完毕，并且已经退出了（1次性任务）</p></li><li><p>Failed Pod 里至少有一个容器以不正常的状态（非 0 的返回码）退出。需要查看 Pod 的 Events和日志</p></li><li><p>Unknown Pod 的状态不能持续地被 kubelet 汇报给kube-apiserver——主从节点（Master 和 Kubelet）间的通信出现了问题</p><ul><li><p>Conditions</p><p>type：PodScheduled、Ready、Initialized，以及 Unschedulable,主要用于描述造成当前 Status 的具体原因是什么。</p><ul><li><p>Pending: 对应的 Condition 是 Unschedulable， 调度出现了问题。</p></li><li><p>Ready： Pod 不仅已经正常启动（Running 状态），而且已经可以对外提供服务了</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>15 深入理解Pod对象（二）</p><ul><li> Projected Volume ——具备自动更新的能力</li></ul><p>  这些特殊 Volume 的作用，是为容器提供预先定义好的数据。所以，从容器的角度来看，这些 Volume 里的信息就是仿佛是被Kubernetes“投射”（Project）进入容器中的</p><ul><li><p>Secret</p><p>数据库的验证信息</p><ul><li><p>创建方式</p><ul><li><p>在Pod yaml：先在volumes字段声明挂载的 是projected 类型，并为 Secret 对象指定的名字，再kubectl create secret generic user –from-file=./username.txt，其中user 是为 Secret 对象指定的名字</p></li><li><p>单独YAML</p></li></ul></li><li><p>通过挂载方式进入到容器里的 Secret， kubelet 组件在定时维护这些 Volume<br>一旦其对应的 Etcd 里的数据被更新，这些 Volume 里的文件内容，同样也会被更新，但会有一定的延时。所以在编写应用程序时，在发起数据库连接的代码处写好重试和超时的逻辑，绝对是个好习惯</p></li></ul></li><li><p>ConfigMap</p><p>环境变量</p><ul><li>与Secret基本一致，区别是不需要加密其中的信息</li></ul></li><li><p>Downward API</p><ul><li><p>声明要暴露 Pod 的某些信息（Pod 里的容器进程启动之前就能确定的信息）给容器，具体的可以查阅一下官方文档.例如</p><ul><li><p>使用 fieldRef 声明：</p><ul><li><p>spec.nodeName - 宿主机名字   </p></li><li><p>status.hostIP - 宿主机 IP</p></li><li><p><a href="http://metadata.name/">metadata.name</a> - Pod 的名字</p></li><li><p>metadata.namespace - Pod 的 Namespace等</p></li></ul></li><li><p>使用 resourceFieldRef 声明：</p><ul><li><p>容器的 CPU limit</p></li><li><p>容器的 CPU request</p></li><li><p>容器的 memory limit</p></li><li><p>容器的 memory request</p></li></ul></li></ul></li></ul></li><li><p>ServiceAccountToken（特殊的Secret对象）？？？有点模棱两可</p><p>Service Account（k8s进行权限分配的对象） 的授权信息（Token）和文件，实际保存在ServiceAccountToken</p><ul><li>从容器里直接访问Kubernetes 的 API 需要ServiceAccountToken的Token<br>Kubernetes 其实在每个 Pod 创建的时候，自动在它的spec.volumes 部分添加上了默认 ServiceAccountToken 的定义，然后自动给每个容器加上了对应的 volumeMounts 字段。简单说，默认就加载了授权信息可以访问k8sAPI</li></ul></li><li><p>容器健康检查和恢复机制</p><p>为 Pod 里的容器定义一个健康检查“探针”（Probe），kubelet 根据 Probe 的返回值决定容器的状态</p><ul><li><p>健康检查</p><ul><li><p>livenessProbe字段，kubelet 根据 健康检查“探针”Probe 的返回值决定容器的状态</p></li><li><p>readinessProbe，决定的这个 Pod 是不是能被通过 Service 的方式访问到，而并不影响 Pod 的生命周期</p></li></ul></li><li><p>Pod 恢复机制 </p><p>Pod 的恢复过程是重新创建容器，永远都是发生在当前节点上，除非使用Deployment控制器</p><ul><li><p>restartPolicy</p><ul><li><p>pod.spec.restartPolicy默认是Always。<br>但如果只计算 1+1=2，计算完成输出结果后退出，变成 Succeeded 状态；所以设为Always没有意义</p></li><li><p>OnFailure: 只在容器 异常时才自动重启容器</p></li><li><p>Never: 从来不重启容器<br>需要关心容器退出后的日志、文件和目录时这样设置</p></li></ul></li><li><p>列表信息的STATUE字段</p><ul><li><p>Failed的场景</p><ul><li><p>运行1个容器的pod在restartPolicy=Never时出现</p></li><li><p>运行多个容器的pod中所有容器异常</p></li></ul></li></ul></li></ul></li></ul></li><li><p>（运维人员预先定义）PodPreset  + （开发人员编写,标记上相关的selector）pod  = 完整的pod yaml<br>PodPreset  里定义的内容会在 Pod API 对象被创建之前追加在这个对象本身上，不会影响任何 Pod 的控制器的定义，比如这个Pod的 Deployment 对象本身是永远不会被 PodPreset改变，k8s还会Merge多个 PodPreset 要做的修改，如果它们要做的修改有冲突，这些冲突字段就不会被修改</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;13 为什么需要Pod？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;背景：容器的“单进程模型”&lt;br&gt;容器没有管理多个进程的能力，因为容器里 PID=1 的进程就是应用本身，其他的进程都是这个 PID=1 进程的子进程，用户进程没有管理其他进程的能力&lt;/p&gt;
&lt;/l</summary>
      
    
    
    
    <category term="Kubernetes" scheme="https://jiac3366.github.io/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/26/Golang/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/"/>
    <id>https://jiac3366.github.io/2021/10/26/Golang/1108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/</id>
    <published>2021-10-26T13:20:32.639Z</published>
    <updated>2021-10-26T13:44:32.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1108-IP-地址无效化"><a href="#1108-IP-地址无效化" class="headerlink" title="1108. IP 地址无效化"></a>1108. IP 地址无效化</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>golang <code>string</code>和<code>[]byte</code>的区别？</li><li>如何转换？</li></ul><p>根据[golang string和<a href="https://www.cnblogs.com/zhangboyu/p/7623712.html">]byte的对比 - 张伯雨 - 博客园 (cnblogs.com)</a>可知：</p><ul><li><code>string</code>类型无法修改其中的某个字符，当我们操作的粒度小到具体1个字符时，用<code>[]byte</code></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul><li>申请一块<code>[]byte</code>的内存，j作为遍历指针</li><li>直接遍历IP地址<ul><li>if  遇到”.”，将”.”更换为 “[“ + “.” + “]”</li></ul></li></ul><p>TIPS：我们注意，IPv4地址一般三个“.”，这里需要在原长度的基础上加6.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n,j := <span class="built_in">len</span>(address), <span class="number">0</span></span><br><span class="line">rets := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n+<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;n;i++ &#123;</span><br><span class="line"><span class="keyword">if</span> address[i] == <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">rets[j]=<span class="string">&#x27;[&#x27;</span></span><br><span class="line">j++</span><br><span class="line">rets[j]=<span class="string">&#x27;.&#x27;</span></span><br><span class="line">j++</span><br><span class="line">rets[j]=<span class="string">&#x27;]&#x27;</span></span><br><span class="line">j++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rets[j] = address[i]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(rets)</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1108-IP-地址无效化&quot;&gt;&lt;a href=&quot;#1108-IP-地址无效化&quot; class=&quot;headerlink&quot; title=&quot;1108. IP 地址无效化&quot;&gt;&lt;/a&gt;1108. IP 地址无效化&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jiac3366.github.io/2021/10/25/Golang/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>https://jiac3366.github.io/2021/10/25/Golang/347.%20%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</id>
    <published>2021-10-25T12:36:56.452Z</published>
    <updated>2021-10-26T13:35:42.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>此题考查堆相关算法的TopK问题<ul><li>1、实现最小堆</li><li>2、遍历所给的数据<ul><li>若堆不满，直接入堆</li><li>若堆满，if 当前当前元素 &gt; 最小堆的root：入堆</li></ul></li><li>3、输出堆中的元素即为TopK的元素</li></ul></li></ul><h2 id="实现堆"><a href="#实现堆" class="headerlink" title="实现堆"></a>实现堆</h2><p>这里简单介绍golang如何实现最小堆，如已掌握可以跳过。题解在最下方。</p><p>官方**<code>&quot;container/heap&quot;</code>**包提供的堆方法（以下<code>Interface1</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface1 <span class="keyword">interface</span> &#123;</span><br><span class="line">   sort.Interface</span><br><span class="line">   Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">   Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而继续点开<code>sort.Interface</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Less reports whether the element with</span></span><br><span class="line"><span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得知，我们需要实现不少方法</p><ul><li><p>总体思路是</p><ul><li>自定义一个数组，数组中需要实现上述2个接口的方法，接口分别是<code>Interface1</code>和<code>Interface2</code>，取名为<strong>PriorityQueue</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An Item is something we manage in a priority queue.</span></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">value    <span class="keyword">string</span> <span class="comment">// The value of the item; arbitrary.</span></span><br><span class="line">priority <span class="keyword">int</span>    <span class="comment">// The priority of the item in the queue.</span></span><br><span class="line"><span class="comment">// The index is needed by update and is maintained by the heap.Interface methods.</span></span><br><span class="line">index <span class="keyword">int</span> <span class="comment">// The index of the item in the heap.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A PriorityQueue implements heap.Interface and holds Items.</span></span><br><span class="line"><span class="keyword">type</span> PriorityQueue []*Item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(pq) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// We want Pop to give us the highest, not lowest, priority so we use greater than here.</span></span><br><span class="line"><span class="keyword">return</span> pq[i].priority &gt; pq[j].priority</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq PriorityQueue)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pq[i], pq[j] = pq[j], pq[i]</span><br><span class="line">pq[i].index = i</span><br><span class="line">pq[j].index = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(*pq)</span><br><span class="line">item := x.(*Item)</span><br><span class="line">item.index = n</span><br><span class="line">*pq = <span class="built_in">append</span>(*pq, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *pq</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">item := old[n<span class="number">-1</span>]</span><br><span class="line">item.index = <span class="number">-1</span> <span class="comment">// for safety</span></span><br><span class="line">*pq = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update modifies the priority and value of an Item in the queue.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pq *PriorityQueue)</span> <span class="title">update</span><span class="params">(item *Item, value <span class="keyword">string</span>, priority <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">item.value = value</span><br><span class="line">item.priority = priority</span><br><span class="line">heap.Fix(pq, item.index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>container/heap</code>堆化、操作<strong>PriorityQueue</strong></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This example creates a PriorityQueue with some items, adds and manipulates an item,</span></span><br><span class="line"><span class="comment">// and then removes the items in priority order.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Example_priorityQueue</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Some items and their priorities.</span></span><br><span class="line">items := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;apple&quot;</span>: <span class="number">2</span>, <span class="string">&quot;pear&quot;</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a priority queue, put the items in it, and</span></span><br><span class="line"><span class="comment">// establish the priority queue (heap) invariants.</span></span><br><span class="line">pq := <span class="built_in">make</span>(PriorityQueue, <span class="built_in">len</span>(items))</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value, priority := <span class="keyword">range</span> items &#123;</span><br><span class="line">pq[i] = &amp;Item&#123;</span><br><span class="line">value:    value,</span><br><span class="line">priority: priority,</span><br><span class="line">index:    i,</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">heap.Init(&amp;pq)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a new item and then modify its priority.</span></span><br><span class="line">item := &amp;Item&#123;</span><br><span class="line">value:    <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">priority: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">heap.Push(&amp;pq, item)</span><br><span class="line">pq.update(item, item.value, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take the items out; they arrive in decreasing priority order.</span></span><br><span class="line"><span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">item := heap.Pop(&amp;pq).(*Item)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2d:%s &quot;</span>, item.priority, item.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 05:orange 04:pear 03:banana 02:apple</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回到题目"><a href="#回到题目" class="headerlink" title="回到题目"></a>回到题目</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;container/heap&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// not just its contents.</span></span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This example inserts several ints into an IntHeap, checks the minimum,</span></span><br><span class="line"><span class="comment">// and removes them in order of priority.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := &amp;IntHeap&#123;<span class="number">100</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">70</span>,<span class="number">2</span>,<span class="number">36</span>,<span class="number">22</span>,<span class="number">5</span>,<span class="number">12</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;\nHeap:&quot;</span>)</span><br><span class="line">heap.Init(h)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;最小值: %d\n&quot;</span>, (*h)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//for(Pop)依次输出最小值,则相当于执行了HeapSort</span></span><br><span class="line">fmt.Println(<span class="string">&quot;\nHeap sort:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(h))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;347-前-K-个高频元素&quot;&gt;&lt;a href=&quot;#347-前-K-个高频元素&quot; class=&quot;headerlink&quot; title=&quot;347. 前 K 个高频元素&quot;&gt;&lt;/a&gt;347. 前 K 个高频元素&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>容器技术 | Docker容器知识个人笔记</title>
    <link href="https://jiac3366.github.io/2021/10/14/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>https://jiac3366.github.io/2021/10/14/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/Docker%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2021-10-14T15:51:55.571Z</published>
    <updated>2021-12-19T16:07:27.377Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>容器 = rootfs(静态视图) + Ns和Cgroups(动态视图)</p></li><li><p>Namespace</p><ul><li><p>docker创建容器进程时，实际是指定了这个进程所需要启用的一组 Namespace 参数，是一种特殊的进程</p><ul><li><p>int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); </p></li><li><p>隔离的Namespace中的一些命令比如ping，netstat不受docker控制，容器是单进程意思是只有1个进程是可控的</p><ul><li><img src="https://api2.mubu.com/v3/document_image/f1e43398-5328-42e9-ab86-6fa103d40447-12600127.jpg" alt="img"></li></ul></li><li><p>缺点：共享宿主机内核，win容器应该不能在linux跑</p></li></ul></li></ul></li><li><p>Cgroup</p><ul><li><p>CPU/Memory</p><ul><li><p>watch ‘ps -aux|grep malloc|grep -v grep’  查看正在分配内存的应用，这个应用的二进制文件名叫malloc<img src="https://api2.mubu.com/v3/document_image/482838cc-cfaa-458c-abcb-08914e65edac-12600127.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/609a203b-3221-436e-bbef-3f4ff11e35ad-12600127.jpg" alt="img"></p></li><li><p>缺点：</p><ul><li>提及最多的自然是 /proc 文件系统，/proc 文件系统不了解 Cgroups 限制的存在<br>容器里执行 top 指令，显示的信息居然是宿主机的 CPU 和内存数据</li></ul></li><li><p>课后问题：如何修复容器中的 top 指令以及 /proc 文件系统中的信息</p><ul><li>A：top 是从 /prof/stats 目录下获取数据，所以道理上来讲，容器不挂载宿主机的该目录就可以了。lxcfs就是来实现这个功能的，做法是把宿主机的 /var/lib/lxcfs/proc/memoinfo 文件挂载到Docker容器的/proc/meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制.（改变容器top读取数据的位置）</li></ul></li></ul></li><li><p>Mount ns</p><ul><li><p>Mount ns跟其他 ns略有不同：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。<br>但我们希望的是：每当创建一个新容器时看到的文件系统就是一个独立的隔离环境，而不是默认继承自宿主机的文件系统。</p></li><li><p>Mount ns 对 chroot 的不断改良，做到默认挂载一个宿主机目录到容器根目录</p><ul><li>chroot $HOME/test /bin/bash<br>使用 $HOME/test 目录作为 /bin/bash进程(容器进程)的根目录</li></ul></li><li><p>目前，为了容器根目录更真实，一般挂载一个完整操作系统的文件系统（比如 Ubuntu16.04 的 ISO）——“容器镜像”，更专业就叫rootfs（根文件系统）。<br>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核，所以容器镜像不含内核，同一台机器上的所有容器，都共享宿主机操作系统的内核</p></li><li><p>Docker核心原理就是为待创建的用户进程：</p><ul><li><p>启用 Linux Namespace</p></li><li><p>设置指定的 Cgroups 参数</p></li><li><p>切换进程的根目录（Change Root）–优先用系统调用pivot_root ，没有就用chroot</p></li></ul></li><li><p>Union FS 联合文件系统</p><ul><li><p>AuFS: 镜像的层（5个）都放置在 /var/lib/docker/aufs/diff 目录下，然后被联合挂载（1个）在 /var/lib/docker/aufs/mnt 里面</p><ul><li><p>？？？？例子中的可读写层 ID  6e3be5d2ecccae7怎么来的<img src="https://api2.mubu.com/v3/document_image/96ea6bb5-b917-4a07-82fc-049808998484-12600127.jpg" alt="img"></p></li><li><p>5合1是如何做到的？信息记录在 /sys/fs/aufs</p><ul><li><p>通过cat /proc/mounts| grep aufs找到/var/lib/docker/aufs/mnt/id 这个id（例子中的6e3be5d2ecccae7）的挂载信息，得到si=972c6d361e6b32ba</p></li><li><p>再通过cat /sys/fs/aufs/si_972c6d361e6b32ba/br[0-9]*得到</p><ul><li>这就是宿主机存放这个镜像的层的真正文件<img src="https://api2.mubu.com/v3/document_image/b8018e6e-f2cd-4fbf-939e-634ce47204c0-12600127.jpg" alt="img"></li></ul></li></ul></li></ul></li><li><p>OverlayFS</p></li></ul></li><li><p>docker创新点：设计了增量rootfs，用到了Union FS</p><ul><li><p>rootfs由三部分组成</p><ul><li><p>读写层（容器层），是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，会被提交到hub被其他人使用</p></li><li><p>Init层（在2大层中间），专门用来存放 /etc/hosts、/etc/resolv.conf 等，不会提交，仅对当前容器有效</p></li><li><p>只读层（镜像层）</p></li></ul></li><li><p>删除只读层：要删除只读层里一个名叫 foo 的文件，实际上是在可读写层创建了一个名叫.wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被.wh.foo 文件“遮挡”起来，“消失”了，即“ro+whiteout”的方式</p></li><li><p>修改只读层：找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件。即“copy on write”的方式</p></li></ul></li></ul></li></ul></li><li><p>Dockerfile</p><ul><li><p>问题：SHELL 和 VOLUME命令</p></li><li><p>CMD和ENTRYPOINTT</p><ul><li>Docker 会为你提供一个隐含的 ENTRYPOINT，即：/bin/sh -c.不指定 ENTRYPOINT 时，CMD 的内容就是 ENTRYPOINT 的参数，实际上运行在容器里的完整进程是：/bin/sh -c CMD</li></ul></li><li><p>每个原语执行后，都会生成一个对应的镜像层。即使原语本身并没有明显地修改文件的操作（比如，ENV 原语），它对应的层也会存在。只不过在外界看来，这个层是空的</p></li><li><p>docker commit 提交增量更新</p><ul><li><p>这里你对镜像roofs做的修改就是copt-on-write，init层避免了 Docker 对 /etc/hosts 等文件做的修改也一起提交.<img src="https://api2.mubu.com/v3/document_image/69f0490b-bee8-43a8-9c7e-395a746c0955-12600127.jpg" alt="img"></p></li><li><p>它发生在宿主机空间，由于 Mount ns的隔离作用，宿主机不知道有目录绑定到容器中，也就是说，宿主机认为容器中可读写层的 /test 目录（/var/lib/docker/aufs/mnt/[可读写层 ID]/test），始终是空的</p></li></ul></li><li><p>docker exec原理：</p><p>加入到一个某个进程已有的 Namespace 当中，达到“进入”这个进程所在容器的目的</p><ul><li><p>docker inspect –format ‘‘  [容器id]   ——查看容器进程id<br>docker inspect [容器id] | grep -I pid</p></li><li><p>ls -l  /proc/容器进程id/ns ——查看这个容器真实的 Namespace 文件, 这样就可以依靠系统调用做有意义的事了</p><ul><li><p>系统调用：setns()，可以指定一个进程进入另一个进程的ns</p></li><li><p>docker提供了：-net参数  让你启动一个容器并“加入”到另一个容器的net ns； –net=host，不会启动net ns，就意味会和宿主机直接共享网络栈<br>docker run -it –net container:4ddf4638572d busybox ifconfig</p></li></ul></li></ul></li><li><p>docker volume原理：</p><p>就算开启了 Mount ns，在执行 chroot（或者 pivot_root）之前，容器进程一直可以看到宿主机上的整个文件系统</p><ul><li><p>指定方式</p><ul><li><p> docker run -v /test …  ——默认在宿主机上创建一个临时目录 /var/lib/docker/volumes/[VOLUME_ID]/_data，然后把它挂载到容器的 /test 目录上</p></li><li><p> docker run -v /home:/test …</p></li></ul></li><li><p>相关执行顺序：容器启动 –&gt; 5合1准备好容器的roofs –&gt; /home挂载到/var/lib/docker/aufs/mnt/[可读写层 ID]/test （此时mount ns已开启，挂载事件只在这个容器里可见，在宿主机上看不见容器内部的这个挂载点，保证了容器的隔离性不会被 Volume 打破）在复习一下？？？inode知识盲区？？？–&gt;chroot系统调用<img src="https://api2.mubu.com/v3/document_image/536cef6d-b347-41ef-aac6-37e957734240-12600127.jpg" alt="img"></p></li><li><p>找的顺序：启动–&gt;docker volume ls 第一个id –&gt;ls /var/lib/docker/volumes/id/_data/</p></li><li><p>08inode知识盲区<img src="https://api2.mubu.com/v3/document_image/c6d3b2af-fdeb-41e3-a9ca-84c30eaeeb72-12600127.jpg" alt="img"></p></li><li><p>容器声明的 Volume 的挂载点虽然出现在读写层，但容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中</p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容器 = rootfs(静态视图) + Ns和Cgroups(动态视图)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Namespace&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;docker创建容器进程时，实际是指定了这个进程所需要启用的一组 Namespace 参数，是一</summary>
      
    
    
    
    <category term="容器技术" scheme="https://jiac3366.github.io/categories/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>

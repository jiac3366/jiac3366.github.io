{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Jiaccc","url":"https://jiac3366.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2021-09-15T13:19:16.012Z","updated":"2021-09-15T13:19:16.012Z","comments":true,"path":"links/index.html","permalink":"https://jiac3366.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-09-15T13:19:16.013Z","updated":"2021-09-15T13:19:16.013Z","comments":false,"path":"tags/index.html","permalink":"https://jiac3366.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-09-15T13:19:16.011Z","updated":"2021-09-15T13:19:16.011Z","comments":false,"path":"categories/index.html","permalink":"https://jiac3366.github.io/categories/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2021-09-15T14:01:41.464Z","updated":"2021-09-15T13:19:16.010Z","comments":false,"path":"/404.html","permalink":"https://jiac3366.github.io/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-09-15T13:19:16.012Z","updated":"2021-09-15T13:19:16.012Z","comments":false,"path":"repository/index.html","permalink":"https://jiac3366.github.io/repository/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-15T13:19:16.011Z","updated":"2021-09-15T13:19:16.011Z","comments":false,"path":"about/index.html","permalink":"https://jiac3366.github.io/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"","slug":"操作系统/1操作系统","date":"2021-10-04T04:27:46.744Z","updated":"2021-10-04T04:35:42.350Z","comments":true,"path":"2021/10/04/操作系统/1操作系统/","link":"","permalink":"https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"线程同步","categories":[],"tags":[]},{"title":"","slug":"操作系统/线程同步","date":"2021-10-04T04:27:43.200Z","updated":"2021-10-04T04:27:43.367Z","comments":true,"path":"2021/10/04/操作系统/线程同步/","link":"","permalink":"https://jiac3366.github.io/2021/10/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/","excerpt":"","text":"忙等待锁-自旋锁 当获取不到锁时，线程就会⼀直 wile 循环，不做任何事情，所以就被称为「忙等待锁」，也被称 为⾃旋锁这是最简单的⼀种锁，⼀直⾃旋，利⽤ CPU 周期（占用着CPU），直到锁可⽤。在单处理器上，需要抢占式的调度器（即 不断通过时钟中断⼀个线程，运⾏其他线程）。否则，⾃旋锁在单 CPU 上⽆法使⽤，因为⼀个⾃旋的线程 永远不会放弃 CPU。？ 无等待锁 当没获取到锁的时候，就把当前线程放⼊到锁的等待队列，然后执⾏调度程序，把 CPU 让给其他线程执⾏","categories":[],"tags":[]},{"title":"HTTP的缓存代理","slug":"透视HTTP协议/HTTP的缓存代理","date":"2021-10-04T03:11:25.120Z","updated":"2021-10-04T08:14:38.321Z","comments":true,"path":"2021/10/04/透视HTTP协议/HTTP的缓存代理/","link":"","permalink":"https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86/","excerpt":"","text":"HTTP的缓存代理HTTP缓存功能主要由proxy server实现 client和proxy缓存控制的区别因为proxy server面对多client，所以origin server要对他作多点限制 区别是客户端or代理的缓存 若是客户端，用cache-control: private标识 若是代理，用cache-control: public 区别cache验证的字段 代理使用proxy_revalidate而不是must_revalidate,要求代理的缓存过期后回源server验证，client不回源 区别cache生存时间字段 使用s-maxage限定缓存在代理上能存多久，client仍然使用max-age 代理专属属性：no-transform，不准对缓存的数据做任何手脚，甚至是优化 详细请看20/21的流程图 客户端的缓存控制补充 max-stale=3: 废旧度要小于3天，至多max-age过期3天还能使用 min-fresh=4: 新鲜度要大于4天，max-age前4天内都不使用 only-if-cached: 只接受代理的缓存，不接受源 代理如何知道改次请求是否与上次的请求匹配 vary字段——“vary字段记录下一些字段，这些字段是响应这个请求结果的依据”，所以代理收到带vary会提取里面的请求头计算hash，存入缓存或与已有的缓存作匹配 删除URI对应的缓存数据 自定义请求方法“PURGE”发给代理（?） 试着自己画出缓存的流程图","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"}],"tags":[]},{"title":"HTTP的代理服务","slug":"透视HTTP协议/HTTP的代理服务","date":"2021-10-04T02:46:13.762Z","updated":"2021-10-04T08:14:34.575Z","comments":true,"path":"2021/10/04/透视HTTP协议/HTTP的代理服务/","link":"","permalink":"https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E7%9A%84%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"HTTP的代理服务 代理头字段：Via（请求头/响应头都有） 谁转发了报文，就在报文的Via字段接着加上自己的IP? X-Forwarded-For和X-Real-IP若只有1层代理，2个字段一样 X-Forwarded-For追加的是请求方的IP——“为谁而转发”，最左边的即为client的IP X-Real-IP只记录client的IP X-Forwarded要修改HTTP内容，性能低下，且在HTTPS中不能实现","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"}],"tags":[]},{"title":"Cookie","slug":"透视HTTP协议/Cookie","date":"2021-10-04T01:37:19.327Z","updated":"2021-10-04T08:14:29.256Z","comments":true,"path":"2021/10/04/透视HTTP协议/Cookie/","link":"","permalink":"https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/Cookie/","excerpt":"","text":"Cookie Cookie有效期用Expires, Max-Age属性设置server过于健忘，有时会设多条cookie，用“；”分隔 Expires和Max-Age Expires为截止日期，是个绝对时间，如果更改本机时间可能会造成失效. Max-Age+报文收到的时间即等于失效时间，优先使用 Domain和Path组成Cookie作用域让client发送Cookie给指定URI(?) Domain指定所属域 Path指定路径，一般用”/“，代表域名所有的路径都使用 HttpOnly 防止客户端使用非HTTP方式 (例如Js) 获取Cookie——预防XSS SameSite:value（?）可以防XSRF 值为Strict：不能随跳转URI跨站发送 值为Lax：允许GET/HEAD等安全方法，但禁止POST跨站发送 Secure 仅能用HTTPS传输Cookie，但Cookie在Browser明文存在 Cookie最大作用：身份识别-广告追踪 google给你贴个Cookie，别的网站通过读取它的Cookie（第三方Cookie）对你推广告 会话Cookie 不设置Expires和Max-Age，浏览器一关就失效，过期时间显示为“session”或“N/A” Cookie大小&lt;=4k，以数据库记录(sqlite)存放","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"}],"tags":[]},{"title":"重定向和跳转","slug":"透视HTTP协议/重定向和跳转","date":"2021-10-04T01:18:14.240Z","updated":"2021-10-04T08:14:25.353Z","comments":true,"path":"2021/10/04/透视HTTP协议/重定向和跳转/","link":"","permalink":"https://jiac3366.github.io/2021/10/04/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%B7%B3%E8%BD%AC/","excerpt":"","text":"重定向和跳转响应报文中有字段：Location: [URI] 301永久重定向：意味着原URI不再存在了，今后必须用新的URI，浏览器可能会更新书签等，爬虫也会更新 302临时重定向：浏览器和爬虫会认为临时不可用原URI，执行简单跳转 303.307.308类似，但有细节上的约束，慎用！ 重定向是server控制浏览器的手段 域名更换/网站维护等避免404出现 增加多个类似的域名入口再跳到主站点 重定向场景 301-涉及到重大改变的，对SEO也挺重要 302-涉及到临时维护跳转到通知页或服务降级（双十一促销） 一个跳转会有2次“请求-应答”(?) 浏览器的前进和后退——跳转重定向（?）","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"}],"tags":[]},{"title":"HTTP连接管理","slug":"透视HTTP协议/HTTP连接管理","date":"2021-10-03T05:07:24.334Z","updated":"2021-10-04T08:14:46.281Z","comments":true,"path":"2021/10/03/透视HTTP协议/HTTP连接管理/","link":"","permalink":"https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86/","excerpt":"","text":"HTTP连接管理 长连接Connection:&quot;Keep-alive&quot;长连接：第一次请求后的请求复用第1次请求打开的TCP连接 1.1默认启用长连接,client发送Connection:&quot;Keep-alive&quot;表示使用长连接，但server不会管这么多只要支持就发这字段. server一般不主动关闭连接，可以设置Nginx的策略关闭 keepalive_timeout 超时时间 keepalive_requests 长连接可发的最大请求数 如何优化缓解HTTP1.1队头阻塞——“请求-应答模型导致”类似上班打卡，只要有一个人打不上卡，后面都等着 “并发连接”（买多几台打卡机）=&gt;client同时对1server发起多个长连接，一般一个client最多并发6~8个长连接 “域名分片”（前台放不下这么多打卡机，在每个楼层放吧），本质上也是数量解决，HTTP对一个域名并发有限制(?)，那就多开几个域名，绑定到同一个服务器 PS： 长连接最重要是区分多个报文的开始和结束，使用Content-Length正确标记报文结束。对于流式传输，必须用分块传输编码(Transfer-Encoding:chunked?) Connection:Upgrade + 状态码101表示协议升级表示从HTTP切换到WebSocket","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"}],"tags":[]},{"title":"数据类型与编码","slug":"透视HTTP协议/数据类型与编码","date":"2021-10-03T04:41:00.843Z","updated":"2021-10-04T08:14:22.634Z","comments":true,"path":"2021/10/03/透视HTTP协议/数据类型与编码/","link":"","permalink":"https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81/","excerpt":"","text":"数据类型与编码 数据类型与编码 HTTP告诉上层应用这是什么数据——数据类型、压缩格式 MIME数据类型 压缩格式 gzip(GUN zip压缩格式 最流行) Nginx gzip on仅仅对文本数据有效 deflate(zlib压缩格式) br(专门HTTP优化的压缩算法) 相关字段（Accept-xxx代表想要对方要干的，Content-xxx代表自己是这么干的） Accept(client告诉server可接受的MIME类型) Content-Type（server告诉client实际发了啥MIME） eg: text/html; charset=utf-8 Accept-Encoding（client支持的压缩格式） Content-Encoding（server实际用的压缩格式） 以上2个不发说明 client不支持压缩 server也没有压缩 语言类型与编码 浏览器能解析多种数据类型，但又如何让它显示成不同国家的自然语言呢？ 相关字段 Accept-Language type-subtype:en-GB, en-US, zh-CN Content-Language(少用) Accept-Charset(少用) 注意：没有Content-Charset “Content-Charset”相关内容在Content-Type（server告诉client实际发了啥MIME） 内容协商优先级 分号权重比逗号低 服务器响应的结果 使用vary字段记录响应这个请求结果的依据","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"}],"tags":[]},{"title":"","slug":"透视HTTP协议/1透视HTTP协议","date":"2021-10-03T03:32:56.814Z","updated":"2021-10-04T03:32:22.163Z","comments":true,"path":"2021/10/03/透视HTTP协议/1透视HTTP协议/","link":"","permalink":"https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/1%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"透视HTTP协议 HTTP1.1缺点 请求-应答模式，会造成同步阻塞 以文本格式传输Header，效率下降 数据类型与编码 HTTP传输大文件 HTTP连接管理 重定向和跳转 Cookie HTTP的缓存控制 HTTP的代理服务 HTTP的缓存代理 HTTPS 对称与非对称加密 数字签名与证书 … HTTP2特性概览 HTTP3展望 Nginx、OpenResty WAF CDN Websocket：沙盒里的TCP HTTP性能优化","categories":[],"tags":[]},{"title":"HTTP传输大文件","slug":"透视HTTP协议/HTTP传输大文件","date":"2021-10-03T03:09:44.579Z","updated":"2021-10-04T08:14:32.135Z","comments":true,"path":"2021/10/03/透视HTTP协议/HTTP传输大文件/","link":"","permalink":"https://jiac3366.github.io/2021/10/03/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/HTTP%E4%BC%A0%E8%BE%93%E5%A4%A7%E6%96%87%E4%BB%B6/","excerpt":"","text":"HTTP传输大文件 Transfer-Encoding与Content-Length互斥 在响应头部Transfer-Encoding:chunked表示 交互流程： Server用Accept-Ranges:bytes告知client支持范围请求（视频快进功能）不支持干脆不发 client使用Range:bytes=x-y 告知要的范围eg:一个100字节文件, client要前10字节：Range:bytes=0-10 server收到Range字段后先检查合法性：非法返416，合法返206，并在头字段加Content-Range:byes=x-y client也可以一次性请求多个范围，响应报文数据类型字段为multipart/byteranges表示响应报文体由多段字节序列组成 多段序列报文的格式与分块传输有一点区别","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"}],"tags":[]},{"title":"进程间通信","slug":"进程间通信方式","date":"2021-09-15T14:56:09.563Z","updated":"2021-09-15T14:56:58.773Z","comments":true,"path":"2021/09/15/进程间通信方式/","link":"","permalink":"https://jiac3366.github.io/2021/09/15/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"进程间通信 管道 通信⽅式效率低，不适合进程间频繁地交换数据，匿名管道跟随进程的生命周期 在 shell ⾥⾯执⾏ A | B 命令的时候，A 进程和 B 进程都是 shell 创建出来的⼦进程 如果要进程双向通信，要创建2个管道（不然父进程fork子进程也把管道读写描述符复制了，2者对同一个管道写读造成混乱） ​进程写⼊读取的数据都经过内核 | 匿名管道 特殊文件 在内存 mkfifo myPipe 创建命名管道 ls在文件系统能看到文件类型是p(pipe) 消息队列 相比管道，可以频繁交换数据 ​消息队列跟随内核的生命周期，会有两个宏定义 MSGMAX 和 MSGMNB ，它们以字节为单位，分别定义了⼀条消息的最⼤⻓度和⼀个队列的最⼤⻓度 缺点：⼀是通信不及时，二不适合⽐较⼤数据的传输，三存在⽤户态与内核态之间的数据拷⻉开销 共享内存 拿出⼀块虚拟地址空间来，映射到相同的物理内存中 信号量(p191) 防⽌多进程竞争共享资源造成的数据错乱的保护机制，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。 信号初始化为 1 ，是互斥信号量 在任何时刻只有⼀个进程在访问 信号初始化为 10，是同步信号量 保证进程 A 应在进程 B 之前执⾏ 信号 进程间通信机制中唯⼀的异步通信机制 Ctrl+C 产⽣ SIGINT 信号，表示终⽌该进程 Ctrl+Z 产⽣ SIGTSTP 信号，表示停⽌该进程，但还未结束 Socket Socket 通信不仅可以跨⽹络与不同主机的进程间通信，还可以在同主机上进程间通信 UDP 是没有连接的，不需要调⽤ listen 和 connect，要bind socket类型:6种（协议族：本机/Ipv4/Ipv6，通信特性：字节流/数据报） 本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端⼝，⽽是绑定⼀个本地⽂件，这也就是它们之间的最⼤区别。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://jiac3366.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[]},{"title":"后端知识","slug":"后端存储知识","date":"2021-08-14T10:09:16.833Z","updated":"2021-09-15T14:53:37.756Z","comments":true,"path":"2021/08/14/后端存储知识/","link":"","permalink":"https://jiac3366.github.io/2021/08/14/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86/","excerpt":"","text":"CAP理论 不关注单节点系统，也不关注没有数据共享的多节点系统 事务的ACID特性（AD必须要保证） A 原子性 C 一致性 I 隔离性 D 持久性 C 有流水就有余额变化 I 没提交的事务对于其他事务不可见 实现：（不可能100%实现ACID） 数据库事务——四个隔离级别 区分RC(读提交)和RR(可重复读)——一个事务能否读到其他事务对数据已提交的更新 能： RC、不能：RR（mysql默认） 幻读很少遇到也基本不会影响数据准确性 RR屏蔽掉了其他事务对真实数据的修改，自己无法查询，但实际上数据已存在或已经修改 兼顾【性能、并发、一致性】的交易方案： 1、给账户余额表增加一个 log_id 属性，记录最后一笔交易的流水号 2、首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号 3、然后写入流水记录 4、再更新账户余额，但有条件限定：只有流水号等于之前查询出的流水号时才更新 5、然后检查更新余额的返回值，如果更新成功就提交事务，否则回滚事务。 分布式事务——2PC、3PC、TCC、Saga 和本地消息表 下面例子展示不同模型之间的事务交互 ​分布式事务的“分布式”可以是多主机的系统的事务，也可以是在单机中的不同系统（模型） 实现1：2PC（二阶段提交） 例如:强一致性&amp;并发低场景，订单表（订单系统，下单并绑定消费券id）和消费券表（促销系统，对消费券改为已使用） ​2PC 引入了一个事务协调者的角色，来协调两个系统的数据更新操作保持一致，要么都更新成功，要么都更新失败 1、准备阶段：协调者叫各方做准备工作（除了事务提交的所有工作） 2、提交阶段：收到各方”待命”通知后，统一发号令: “提交” 异常处理: 在准备阶段，如果任何一步出现错误或者是超时，协调者就会给两个系统发送“回滚事务”请求 如果已进入提交阶段，整个分布式事务只能成功，反复重试，直到提交成功。 如果这个阶段发生宕机，包括两个数据库宕机或者订单服务、促销服务所在的节点宕机，还是有可能出现订单库完成了提交，但促销库因为宕机自动回滚，导致数据不一致的情况。 ps: 2PC 这个协调服务最好和订单服务或者优惠券服务放在同一个进程里，进程更少故障点更少性能更好 缺点：执行过程会阻塞服务端的线程和数据库的会话，协调者是一个单点，宕机会导致事务超时 实现2：本地消息表(可以存MQ/DB/File) 例如:适用在没依赖其他资源(eg:下单不需要锁库存) 实时性要求不高场景，订单表和购物车表 1、在执行这个数据库事务过程中，在本地记录一条消息。这个消息就是一个日志，内容就是“清空购物车”这个操作。我们可以让订单库的事务，来保证记录本地消息和订单库的一致性。完成后可以给客户端返回成功响应 2、用一个异步的服务，读取刚刚记录的清空购物车的本地消息，调用购物车系统的服务清空购物车。购物车清空之后，把本地消息的状态更新成已完成就可以了。异步清空购物车这个过程中，如果操作失败了，可以通过重试来解决。 高并发应对方法（并发高-&gt;分库） Redis保护DB 了解常见缓存策略 Read/Write Through Cache Aside （更好，写操作与Read/Write Through不同） 写操作更新成功后删除cache(没有cache就直接返回) ​读操作读不到cache就去读数据库再更新cache 分库 读写分离 读多写少 与用户关联不大的数据，可以用Redis挡，但是涉及到用户订单等关联大的数据呢？ 主节点读写兼顾 从节点只读做热备 主从同步问题 主库提交事务 从库复制（mysql半同步复制） mysql5.7可以配置至少几个从节点复制后就返回相应 ​也可以配置提交事务和复制的先后顺序 ​默认是先等待复制，再提交事务（同步复制）AFTER_SYNC 异步复制有可能丢数据：从节点在复制中主节点挂了 多从库的SLB和高可用方案：HAProxy+KeepAlived 主从延迟问题 主库数据更新后是否需要立刻查询？ 需要 把‘更新、查询’合并成一个事务，所以更新后的查询会被路由到主库 不需要 更新后过几秒返回–&gt;下单后等几秒 ​ 实现： 纯手工方式 组件方式（推荐） 得看编程语言的是否有读写分离组件 代理方式（主流） 不方便修改应用的代码 量大数据应对方法（数据量大-&gt;分表） “拆”——分出历史表 归档历史数据，分出历史订单表 如何删除3个月前的订单？详看14 最后一招——用“分片”分表 引出“分片”：通过某字段找到数据在哪个库哪个表 eg:在订单号的后几位加入用户ID 就可以根据用户查出订单在哪个库哪个表 eg:店铺订单,可以复制一个订单DB，把店铺ID设为Sharding ID ​ 分片算法 时间范围分片 易出现热点问题，适用于数据多并发低的系统 订单表hash分片 取ID与分片数的模 一致性hash算法 hash算法都是为了均匀分布数据 查表法 eg:数据可视化系统:商品名映射到某个表 ​ Redis Cluster 存储海量数据 低成本中小集群 MySQL to Redis Kafka/RocketMQ Binlog实时更新Redis(更通用) 实时解析Binlog –&gt;开源项目：Canal 如何降级或补偿应对数据出现不一致 跨数据系统实时同步 详见笔记p19 MQ多分区存储binlog 因果关系的binlog需要hash到同1分区 对面系统的同步程序多线程消费MQ 海量数据存储方案 分布式存储系统：对象存储、HDFS 点击流、监控日志数据 Kafka、HDFS kafka高吞吐 不无限存 查询能力较差 ​HDFS查询能力好 无限存储 分布式流Pulsar/Bookkeeper、时序数据 (监控数据)InfluxDB/OpenTsDB 海量数据提高查询速度 GB级 给分析系统单独配MySQL 10GB HBase Cassandra ClickHouse 列式DB ES 成本高 内存占用大 但推荐 TB级 定期聚合计算好存在HDFS 再配合Map-Reduce、Spark、Hive做Data聚合计算","categories":[{"name":"后端知识","slug":"后端知识","permalink":"https://jiac3366.github.io/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/"}],"tags":[]},{"title":"SQL必知必会","slug":"SQL必知必会","date":"2021-08-14T09:41:44.577Z","updated":"2021-09-15T14:54:01.483Z","comments":true,"path":"2021/08/14/SQL必知必会/","link":"","permalink":"https://jiac3366.github.io/2021/08/14/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","excerpt":"","text":"进阶 B 树和 B+树区别 数据存储位置 B 树的非叶子节点包含数据，而 B+树所有数据在叶子结点上 数据查询过程 B+树会不断递归地在非叶子节点（非叶子节点上有索引键和指向下一页的指针）上做二分查找，直到找到叶子结点，最后在叶子节点上做二分查找（详细请看“B+树检索[页]查询数据”） B+树特性：B+树可以顺序地访问非叶子节点，做到数据的范围查询 1 个非叶子结点 key 指向的数据在它左右 2 边 key 所指向的数据的范围之内 Hash 索引 hash 索引不能用于 Order/groupby，不能支持最左前缀原则（多个 key 一起计算 hash），不支持模糊查询 适用 key-value 场景，当 mysql 某个条件查询频繁，就给这个条件字段生成自适应索引 适用索引的场景 Where 字段/value 唯一的字段/Distinct 字段/Join 连接字段 同时进行 Group A 和 OrderB 的查询时，应使用对应顺序的(A,B)联合索引 不适用索引的场景 数据太少 数据重复太多 数据更新频繁 索引失效场景 字段进行表达式/函数计算 WHERE 中使用 OR 的 2 个字段没有都建立索引 LIKE 直接跟% 索引列与 NULL 进行判断(所以要把字段设为非空) (A,B)的联合索引用了 B 查询 从数据页理解 B+树查询 页&lt;区(连续)&lt;段&lt;表空间 区：一个区有 64 个连续的页，默认页大小为 16k，所以一个区 1MB 段：区在操作系统中是连续分配的空间，即一个段 区在段中不一定是连续的，段也是数据库分配的单位，例如创建表段、索引段 表空间：一个 DB 由 1 个或多个表空间（逻辑容器）组成，一个表空间有 1 个或多个段，其中 InnoDB 共享（独立）表空间：多（一）张表用一个表空间 InnoDB 页结构 不同 DBMS 页结构不同，通常一页有上千条记录 (1) 文件头 文件头 38B 带有上下文的指针 页头 56B 记录页的状态信息 (2) 页记录 最大最小记录 26B 用户记录 空闲记录 (3)页目录（索引） 将(2)的记录分成若干分组，在页目录存对应数量的 slot，每个 slot 记录每个分组的结尾位置，充当索引的作用二分查找记录（空间换时间） (4)文件尾 8B 其中的校验和会与文件头的校验值作对比 B+树检索[页]查询数据过程 (1)逐层检索 B+树直至找到叶子节点 (2)从页目录的槽查找数据所在的分组(二分查找) (3)找到组后遍历单链表（记录之间是链表链接） 从磁盘 I/O 角度理解 SQL 查询的成本 查看缓冲池的大小，当缓冲池大小&gt;1G 时，缓冲池的实例数才可以修改 [修改缓冲池大小：set global innodb_buffer_pool_size =134217728] 数据页加载的 3 种方式 查询速度：缓冲池&gt;内存&gt;磁盘 内存读取 （1 次读取 1 条记录 1ms） 随机读取 （在磁盘找页，10ms，6ms 等磁盘，3ms 排队，1ms 传输） 顺序读取（批量读取） 存储介质物理特性：顺序读&gt;多次随机读，设磁盘吞吐量 40MB/s，40M/16kB= 0.4ms，每秒读约 2560 页 ​ 统计 SQL 查询成本，可以看到上一条 SQL 要读取页的数量 [SHOW STATUS LIKE ‘last_query_cost’] 三星索引 关于锁 共享锁和排他锁 资源加上共享锁（S 锁）–&gt;只读，加上排他锁（X 锁）–&gt;均不可操作 当 INSERT/DELETE/UPDATE 时，数据库会对记录加 X 锁，当 SELECT 时，默认不加锁​ 意向共享/排他锁：当事务操作某些记录的数据，会在表上添加对应的意向锁，提示其他事务有人”占”了表中的某些记录 因为共享锁允许其他事务加共享锁(不排他)，多个读锁可能出现死锁 当第二个事务使用 UPDATE 等其他上排他锁的操作时，会不停地等待，超时 乐观锁和悲观锁 是程序员对待数据并发风险的一种态度体现 乐观锁（认为别人不会同时写入），使用版本机制或时间戳实现控制同一数据被“同时修改” 悲观，用数据量自身的锁机制 死锁 因为在事务（进程）中，锁的获取是逐步的 有锁的存在，死锁就有可能，eg:2 个事务都对资源获取共享锁，结果都没法更新操作 如何避免死锁 若事务涉及多个表或一个表的大部分数据时，可以一次性锁定多个表或整个表 不同事务并发多张表，可以约定它们访问表的顺序(? 事务隔离以及解决方案 … MVCC 是解决什么问题的？ … 查询优化器如何工作 … 使用性能分析工具定位 SQL 执行慢的原因 … -","categories":[{"name":"SQL","slug":"SQL","permalink":"https://jiac3366.github.io/categories/SQL/"}],"tags":[]}],"categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://jiac3366.github.io/categories/HTTP/"},{"name":"操作系统","slug":"操作系统","permalink":"https://jiac3366.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"后端知识","slug":"后端知识","permalink":"https://jiac3366.github.io/categories/%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86/"},{"name":"SQL","slug":"SQL","permalink":"https://jiac3366.github.io/categories/SQL/"}],"tags":[]}